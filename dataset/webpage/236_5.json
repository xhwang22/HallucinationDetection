{"Ted Childs was responsible for the development of the Windows kernel, the core of the operating system.": [{"url": "https://www.microsoftpressstore.com/articles/article.aspx?p=2201301&seqNum=2", "page_content": "Windows Architecture\n\nThe fundamental design of the Windows operating system, with an executive that runs in kernel mode and a complementary set of user-mode system support processes (smss.exe, csrss.exe, winlogon.exe, and so on) to help manage additional system facilities, has for the most part remained unchanged since the inception of the Windows NT operating system back in the late \u201980s. Each new version of Windows naturally brings about a number of new components and APIs, but understanding how they fit in the architectural stack often starts with knowing how they interact with these core components of the operating system.\n\nKernel Mode vs. User Mode\n\nKernel mode is an execution mode in the processor that grants access to all system memory (including user-mode memory) and unrestricted use of all CPU instructions. This CPU mode is what enables the Windows operating system to prevent user-mode applications from causing system instability by accessing protected memory or I/O ports.\n\nApplication software usually runs in user mode and is allowed to execute code in kernel mode only via a controlled mechanism called a system call. When the application wants to call a system service exposed by code in the OS that runs in kernel mode, it issues a special CPU instruction to switch the calling thread to kernel mode. When the service call completes its execution in kernel mode, the operating system switches the thread context back to user mode, and the calling application is able to continue its execution in user mode.\n\nThird-party vendors can get their code to run directly in kernel mode by implementing and installing signed drivers. Note that Windows is a monolithic system in the sense that the OS kernel and drivers share the same address space, so any code executing in kernel mode gets the same unrestricted access to memory and hardware that the core of the Windows operating system would have. In fact, several parts of the operating system (the NT file system, the TCP/IP networking stack, and so on) are also implemented as drivers rather than being provided by the kernel binary itself.\n\nThe Windows operating system uses the following layering structure for its kernel-mode operations:\n\nKernel Implements core low-level OS services such as thread scheduling, multiprocessor synchronization, and interrupt/exception dispatching. The kernel also contains a set of routines that are used by the executive to expose higher-level semantics to user-mode applications.\n\nImplements core low-level OS services such as thread scheduling, multiprocessor synchronization, and interrupt/exception dispatching. The kernel also contains a set of routines that are used by the executive to expose higher-level semantics to user-mode applications. Executive Also hosted by the same \u201ckernel\u201d module in Windows (NTOSKRNL), and performs base services such as process/thread management and I/O dispatching. The executive exposes documented functions that can be called from kernel-mode components (such as drivers). It also exposes functions that are callable from user mode, known as system services. The typical entry point to these executive system services in user mode is the ntdll.dll module. (This is the module that has the system call CPU instruction!) During these system service calls, the executive allows user-mode processes to reference the objects (process, thread, event, and so on) it implements via indirect abstractions called object handles, which the executive keeps track of using a per-process handle table.\n\nAlso hosted by the same \u201ckernel\u201d module in Windows (NTOSKRNL), and performs base services such as process/thread management and I/O dispatching. The executive exposes documented functions that can be called from kernel-mode components (such as drivers). It also exposes functions that are callable from user mode, known as system services. The typical entry point to these executive system services in user mode is the ntdll.dll module. (This is the module that has the system call CPU instruction!) During these system service calls, the executive allows user-mode processes to reference the objects (process, thread, event, and so on) it implements via indirect abstractions called object handles, which the executive keeps track of using a per-process handle table. Hardware Abstraction Layer The HAL (hal.dll) is a loadable kernel-mode module that isolates the kernel, executive, and drivers from hardware-specific differences. This layer sits at the very bottom of kernel layers and handles key hardware differences so that higher-level components (such as third-party device drivers) can be written in a platform-agnostic way.\n\nThe HAL (hal.dll) is a loadable kernel-mode module that isolates the kernel, executive, and drivers from hardware-specific differences. This layer sits at the very bottom of kernel layers and handles key hardware differences so that higher-level components (such as third-party device drivers) can be written in a platform-agnostic way. Windows and Graphics Subsystem The Win32 UI and graphics services are implemented by an extension to the kernel (win32k.sys module) and expose system services for UI applications. The typical entry point to these services in user mode is the user32.dll module. Figure 1-2 illustrates this high-level architecture. Figure 1-2 Kernel-mode layers and services in the Windows operating system.\n\nUser-Mode System Processes\n\nSeveral core facilities (logon, logoff, user authentication, and so on) of the Windows operating system are primarily implemented in user mode rather than in kernel mode. A fixed set of user-mode system processes exists to complement the OS functionality exposed from kernel mode. Here are a few important processes that fall in this category:\n\nSmss.exe User sessions in Windows represent resource and security boundaries and offer a virtualized view of the keyboard, mouse, and physical display to support concurrent user logons on the same OS. The state that backs these sessions is tracked in a kernel-mode virtual memory space usually referred to as the session space. In user mode, the session manager subsystem process (smss.exe) is used to start and manage these user sessions. A \u201cleader\u201d smss.exe instance that's not associated with any sessions gets created as part of the Windows boot process. This leader smss.exe creates a transient copy of itself for each new session, which then starts the winlogon.exe and csrss.exe instances corresponding to that user session. Although having the leader session manager use copies of itself to initialize new sessions doesn't provide any practical advantages on client systems, having multiple smss.exe copies running concurrently can provide faster logon of multiple users on Windows Server systems acting as Terminal Servers.\n\nWinlogon.exe The Windows logon process is responsible for managing user logon and logoff. In particular, this process starts the logon UI process that displays the logon screen when the user presses the Ctrl+Alt+Del keyboard combination and also creates the processes responsible for displaying the familiar Windows desktop after the user is authenticated. Each session has its own instance of the winlogon.exe process.\n\nThe Windows logon process is responsible for managing user logon and logoff. In particular, this process starts the logon UI process that displays the logon screen when the user presses the Ctrl+Alt+Del keyboard combination and also creates the processes responsible for displaying the familiar Windows desktop after the user is authenticated. Each session has its own instance of the winlogon.exe process. Csrss.exe The client/server runtime subsystem process is responsible for the user-mode portion of the Win32 subsystem (win32k.sys being the kernel-mode portion) and also was used to host the UI message loop of console applications prior to Windows 7. Each user session has its own instance of this process.\n\nThe client/server runtime subsystem process is responsible for the user-mode portion of the Win32 subsystem (win32k.sys being the kernel-mode portion) and also was used to host the UI message loop of console applications prior to Windows 7. Each user session has its own instance of this process. Lsass.exe The local security authority subsystem process is used by winlogon.exe to authenticate user accounts during the logon sequence. After successful authentication, LSASS generates a security access token object representing the user's security rights, which are then used to create the new explorer process for the user session. New child processes created from that shell then inherit their access tokens from the initial explorer process security token. There is only one single instance of this process, which runs in the noninteractive session (known as session 0).\n\nThe local security authority subsystem process is used by winlogon.exe to authenticate user accounts during the logon sequence. After successful authentication, LSASS generates a security access token object representing the user's security rights, which are then used to create the new explorer process for the user session. New child processes created from that shell then inherit their access tokens from the initial explorer process security token. There is only one single instance of this process, which runs in the noninteractive session (known as session 0). Services.exe This system process is called the NT service control manager (SCM for short) and runs in session 0 (noninteractive session). It's responsible for starting a special category of user-mode processes called Windows services. These processes are generally used by the OS or third-party applications to carry out background tasks that do not require user interaction. Examples of Windows services include the spooler print service (spooler); the task scheduler service (schedule); the COM activation services, also known as the COM SCM (RpcSs and DComLaunch); and the Windows time service (w32time). These processes can choose to run with the highest level of user-mode privileges in Windows (LocalSystem account), so they are often used to perform privileged tasks on behalf of user-mode applications. Also, because these special processes are always started and stopped by the SCM process, they can be started on demand and are guaranteed to have at most one active instance running at any time.\n\nAll of the aforementioned system-support processes run under the LocalSystem account, which is the highest privileged account in Windows. Processes that run with this special account identity are said to be a part of the trusted computing base (TCB) because once user code is able to run with that level of privilege, it is also able to bypass any checks by the security subsystem in the OS.\n\nUser-Mode Application Processes\n\nEvery user-mode process (except for the leader smss.exe process mentioned earlier) is associated with a user session. These user-mode processes are boundaries for a memory address space. As far as scheduling in Windows is concerned, however, the most fundamental scheduling units remain the threads of execution and processes are merely containers for those threads. It's also important to realize that user-mode processes (more specifically, the threads they host) also often run plenty of code in kernel mode. Although your application code might indeed run in user mode, it's often the case that it also calls into system services (through API layers that call down to NTDLL or USER32 for the system call transitions) that end up transitioning to kernel mode on your behalf. This is why it makes sense to always think of your software (whether it's user-mode software or kernel drivers) as an extension of the Windows operating system and also that you understand how it interacts with the \u201cservices\u201d provided by the OS.\n\nProcesses, in turn, can be placed in containers called job objects. These executive objects can be very useful to manage a group of processes as a single unit. Unlike threads and processes, job objects are often overlooked when studying the Windows architecture despite their unique advantages and the useful semantics they provide. Figure 1-3 illustrates the relationship between these fundamental objects.\n\nJob objects can be used to provide common execution settings for a set of processes and, among other things, to control the resources used by member processes (such as the amount of memory consumed by the job and the processors used for its execution) or their UI capabilities.\n\nOne particularly useful feature of job objects is that they can be configured to terminate their processes when their user-mode job handle is closed (either using an explicit kernel32!CloseHandle API call, or implicitly when the kernel runs down the handles in the process handle table when the process kernel object is destroyed). To provide a practical illustration, the following C++ program shows how to take advantage of the job-object construct exposed by the Windows executive in a C++ user-mode application to start a child (\u201cworker\u201d process and synchronize its lifetime with that of its parent process. This is often useful in the case of worker processes whose sole purpose is to serve requests in the context of their parent process, in which case it becomes critical not to \u201cleak\u201d those worker instances should the parent process die unexpectedly. (The reverse is more straightforward because the parent process can easily monitor when the child dies by simply waiting on the worker process handle to become signaled using the kernel32!WaitForSingleObject Win32 API.)\n\nTo follow this experiment, remember to refer back to the Introduction of this book, which contains step-by-step instructions for how to build the companion source code.\n\n// // C:\\book\\code\\chapter_01\\WorkerProcess>main.cpp // class CMainApp { public: static HRESULT MainHR() { HANDLE hProcess, hPrimaryThread; CHandle shProcess, shPrimaryThread; CHandle shWorkerJob; DWORD dwExitCode; JOBOBJECT_EXTENDED_LIMIT_INFORMATION exLimitInfo = {0}; CStringW shCommandLine = L\"notepad.exe\"; ChkProlog(); // // Create the job object, set its processes to terminate on // handle close (similar to an explicit call to TerminateJobObject), // and then add the current process to the job. // shWorkerJob.Attach(CreateJobObject(NULL, NULL)); ChkWin32(shWorkerJob); exLimitInfo.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE; ChkWin32(SetInformationJobObject( shWorkerJob, JobObjectExtendedLimitInformation, &exLimitInfo, sizeof(exLimitInfo))); ChkWin32(AssignProcessToJobObject( shWorkerJob, ::GetCurrentProcess())); // // Now launch the new child process (job membership is inherited by default) // wprintf(L\"Launching child process (notepad.exe) ...\n\n\"); ChkHr(LaunchProcess( shCommandLine.GetBuffer(), 0, &hProcess, &hPrimaryThread)); shProcess.Attach(hProcess); shPrimaryThread.Attach(hPrimaryThread); // // Wait for the worker process to exit // switch (WaitForSingleObject(shProcess, INFINITE)) { case WAIT_OBJECT_0: ChkWin32(::GetExitCodeProcess(shProcess, &dwExitCode)); wprintf(L\"Child process exited with exit code %d.\n\n\", dwExitCode); break; default: ChkReturn(E_FAIL); } ChkNoCleanup(); } };\n\nOne key observation here is that the parent process is assigned to the new job object before the new child process is created, which allows the worker process to automatically inherit this job membership. This means in particular that there is no time window in which the new process would exist without being a part of the job object. If you kill the parent process (using the Ctrl+C signal, for example), you will notice that the worker process (notepad.exe in this case) is also terminated at the same time, which was precisely the desired behavior.\n\nC:\\book\\code\\chapter_01\\WorkerProcess>objfre_win7_x86\\i386\\workerprocess.exe Launching child process (notepad.exe) ... ^C\n\nLow-Level Windows Communication Mechanisms\n\nWith code executing in kernel and user modes, and also inside the boundaries of per-process address spaces in user mode, the Windows operating system supports several mechanisms for allowing components to communicate with each other.\n\nCalling Kernel-Mode Code from User Mode\n\nThe most basic way to call kernel-mode code from user-mode components is the system call mechanism mentioned earlier in this chapter. This mechanism relies on native support in the CPU to implement the transition in a controlled and secure manner.\n\nOne inherent drawback to the system call mechanism is that it relies on a hard-coded table of well-known executive service routines to dispatch the request from the client code in user mode to its intended target service routine in kernel mode. This doesn't extend well to kernel extensions implemented in the form of drivers, however. For those cases, another mechanism\u2014called I/O control commands (IOCTL)\u2014is supported by Windows to enable user-mode code to communicate with kernel-mode drivers. This is done through the generic kernel32!DeviceIoControl API, which takes the user-defined IOCTL identifier as one of its parameters and also a handle to the device object to which to dispatch the request. The transition to kernel mode is still performed in the NTDLL layer (ntdll!NtDeviceIoControlFile) and internally also uses the system call mechanism. So, you can think of the IOCTL method as a higher-level user/kernel communication protocol built on top of the raw system call services provided by the OS and CPU.\n\nInternally, I/O control commands are processed by the I/O manager component of the Windows executive, which builds what is called an I/O request packet (IRP for short) that it then routes to the device object requested by the caller from user mode. IRP processing in the Windows executive uses a layered model where devices have an associated driver stack that handles their requests. When an IRP is sent to a top-level device object, it travels through its device stack starting at the top, passing through each driver in the corresponding device stack and giving it a chance to either process or ignore the command. In fact, IRPs are also used in kernel mode to send commands to other drivers so that the same IRP model is used for interdriver communication in the kernel. Figure 1-4 depicts this architecture.\n\nCalling User-Mode Code from Kernel Mode\n\nCode that runs in kernel mode has unrestricted access to the entire virtual address space (both the user and kernel portions), so kernel mode in theory could invoke any code running in user mode. However, doing so requires first picking a thread to run the code in, transitioning the CPU mode back to user mode, and setting up the user-mode context of the thread to reflect the call parameters. Fortunately, however, only the system code written by Microsoft really needs to communicate with random threads in user mode. The drivers you write, on the other hand, need to call back to user mode only in the context of a device IOCTL initiated by a user-mode thread, so they do not need a more generic kernel-mode to user-mode communication mechanism.\n\nA standard way for the system to execute code in the context of a given user-mode thread is to send an asynchronous procedure call (APC) to that thread. For example, this is exactly how thread suspension works in Windows: the kernel simply sends an APC to the target thread and asks it to execute a function to wait on its internal thread semaphore object, causing it to become suspended. APCs are also used by the system in many other scenarios, such as in I/O completion and thread pool callback routines, just to cite a couple.\n\nInterprocess Communication\n\nAnother way for communicating between user-mode processes and code in kernel mode, as well as between user-mode processes themselves, is to use the advanced local procedure call (ALPC) mechanism. ALPC was introduced in the Windows Vista timeframe and is a big revision of the LPC mechanism, a feature that provided in many ways the bloodline of low-level intercomponent communication in Windows since its early releases.\n\nALPC is based on a simple idea: a server process first opens a kernel port object to receive messages. Clients can then connect to the port if allowed by the server owning the port and start sending messages to the server. They are also able to wait until the server has fetched and processed the message from the internal queue that's associated with the ALPC port object.\n\nIn the case of user/user ALPC, this provides a basic low-level interprocess communication channel. In the case of kernel/user ALPC channels, this essentially provides another (indirect) way for user-mode applications to call code in kernel mode (whether it's in a driver or in the kernel module itself) and vice versa. An example of this communication is the channel that's established between the lsass.exe user-mode system process and the security reference monitor (SRM) executive component in kernel mode, which is used, for example, to send audit messages from the executive to lsass.exe. Figure 1-5 illustrates this architecture.\n\nALPC-style communication is used extensively in the operating system itself, most notably as it pertains to this book to implement the low-level communication protocol that native user-mode debuggers employ to receive various debug events from the process they debug. ALPC is also used as a building block in higher-level communication protocols such as local RPC, which in turn is used as the transport protocol in the COM model to implement interprocess method invocations with proper parameter marshaling."}, {"url": "https://link.springer.com/chapter/10.1007/978-3-030-16053-1_10", "page_content": "To develop a source code base as large as the kernel, it is undoubtedly a substantial educational, technical, and academic gain. The construction of an Operating System (OS) arouses interest in the matter of actually knowing how a computer system behind the graphical screen and even behind the black screen of the well-known command terminal [1,2,3,4,5,6].\n\nA Virtual Machine (VM) consists of an emulated OS running as an application on a computer. It is a computer environment software in which an OS or program can be installed and run, in a very simplified way; it functions as a \u201ccomputer inside the computer\u201d [10, 11]. VMs are extremely useful, allowing to run other OSs, having access to all the necessary software for the desired task, as in the case of this project, OSs still in the development stage [10, 11]. A VM behaves like a complete physical machine that can run its OS, similar to a traditional OS that is in control of the machine.\n\nThis project is geared towards the development of kernels for particular machines architectures (e.g., an FPGA-based reconfigurable processor) and to develop courseware on OS [1,2,3,4, 7,8,9].\n\nUsing a VM to test the development, besides being recommended is much more advantageous than restarting the computer with every change or change, or having to transfer the files from the development (host) machine to the testing (target) machine [10, 11].\n\nFor the development of the Kernel was used a VM with the Linux Ubuntu OS. After the Kernel development, then it was loaded on a Linux VM, another Windows VM, and on a physical machine with no loaded OS.\n\nThe present paper is organized as follows: Sect. 2 discusses the kernel. Section 3 presents and describes the materials and methods. Section 4 presents the methodology of the experiment. Section 5 the results and, finally, in Sect. 6, the conclusions are presented as the potential of the research."}, {"url": "https://pediaa.com/what-is-the-difference-between-windows-kernel-and-linux-kernel/", "page_content": "The main difference between Windows Kernel and Linux Kernel is that Windows kernel, which is in Windows Operating System, is a commercial software while Linux Kernel, which is in the Linux Operating System, is an open source software.\n\nThe kernel is the core of the operating system. It performs functionalities such as communicating with hardware devices, process management, file handling, and many other tasks. Various operating systems have different kernels depending on the type of OS. Moreover, devices in Windows and Linux have different kernels.\n\nKey Areas Covered\n\n1. What is Windows Kernel\n\n\u2013 Definition, Functionality\n\n2. What is Linux Kernel\n\n\u2013 Definition, Functionality\n\n3. What is the Difference Between Windows Kernel and Linux Kernel\n\n\u2013 Comparison of Key Differences\n\nKey Terms\n\nKernel, Linux Kernel, Windows Kernel\n\nWhat is Windows Kernel\n\nThe devices with the Microsoft Windows operating system consist of the windows kernel. This kernel is called the Windows NT kernel. It is capable of working with both uniprocessor and symmetrical multiprocessor-based computers, and therefore, referred to as hybrid kernel as well. Windows architecture consists of windows kernel, hardware abstraction layer (HAL), drivers and other supporting services. These services operate in the kernel mode.\n\nFurthermore, the windows system can operate in two modes: the user mode and kernel mode. The programs running in the user mode has limited access to system resources. However, the programs running in the kernel model has no restrictions to access system memory, hardware, and resources. The user mode is capable of sending IO requests to the relevant kernel mode device drivers by using the IO manager.\n\nThe Windows kernel performs various functionalities including multiprocessor synchronization, supporting threads, interrupt scheduling, and dispatching. It also handles the traps and exceptions. Moreover, the kernel initializes the device drives at the time of booting up the system.\n\nWhat is Linux Kernel\n\nThe kernel in the Linux based systems is called a Linux kernel. One major reason for the popularity of the Linux kernel is that it is free and open source. It has contributors all over the world.\n\nIn Linux systems, the user programs can interact with the kernel by the Application Programming Interface (API). The device drivers control the hardware as a part of kernel\u2019s functionality. There is an interface between the kernel and loadable kernel modules (LKMs).\n\nMoreover, the Linux kernel exists in the personal computers and servers. It is available in embedded devices such as routers, wireless access points, PBXes, smart TVs, etc. as well. The popular mobile operating system Android also uses the Linux kernel to implement its functionalities.\n\nDifference Between Windows Kernel and Linux Kernel\n\nDefinition\n\nWindows kernel is a commercial kernel of Windows operating system developed by Microsoft. In contrast, the Linux kernel is an open source Unix-like computer operating system kernel. Hence, this is the main difference between Windows Kernel and Linux Kernel.\n\nDeveloper\n\nMicrosoft developed the Windows kernel while Linux Torvalds developed Linux kernel.\n\nAccess to Source Code\n\nAccess to source code is another difference between Windows Kernel and Linux Kernel. There is no access to source code of the windows kernel. However, there is full access to the source code of the Linux kernel.\n\nArchitecture\n\nMoreover, one other difference between Windows Kernel and Linux Kernel is that the Windows kernel has hybrid architecture, but Linux kernel has monolithic architecture.\n\nFile Access Control\n\nFurthermore, Windows uses Access Control List (ACL) for file access control. In contrast, Linux uses traditional Unix permissions and POSIX ACL for file access control.\n\nGUI Stack\n\nGUI stack is another difference between Windows Kernel and Linux Kernel. Windows includes a GUI stack in the kernel. However, in Linux, the GUI stack is in the user-space.\n\nSupport for Multi-users\n\nBesides, Windows support multiple users and sessions but depend on the versions and editions. Meanwhile, Linux supports 100 % multi-user environment.\n\nConfigurations\n\nConfigurations is also a difference between Windows Kernel and Linux Kernel. Windows maintain a registry to store configurations while Linux maintains the configurations in files.\n\nDevices\n\nWhile Windows kernel has different mechanisms for different devices, every device is a file for the Linux kernel. Therefore, this is one important difference between Windows Kernel and Linux Kernel.\n\nConclusion\n\nThe difference between Windows Kernel and Linux Kernel is that the Windows kernel, which is in the Windows Operating System, is a commercial software while the Linux Kernel, which is in the Linux Operating System, is an open source software.\n\nReference:\n\n1. \u201cArchitecture of Windows NT.\u201d Wikipedia, Wikimedia Foundation, 15 Oct. 2018, Available here.\n\n2. \u201cLinux Kernel.\u201d Wikipedia, Wikimedia Foundation, 18 Nov. 2018,\n\nAvailable here.\n\n3. \u201cComparison of Operating System Kernels.\u201d Wikipedia, Wikimedia Foundation, 23 Oct. 2018, Available here.\n\nImage Courtesy:\n\n1. \u201c2360920\u201d (CC0) via Pixabay\n\n2. \u201cHow the Linux OS Was Announced to the World in 1991\u201d By methodshop .com (CC BY-SA 2.0) via Flickr"}, {"url": "https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/windows-kernel-mode-kernel-library", "page_content": "Table of contents\n\nWindows Kernel-Mode Kernel Library\n\nArticle\n\n12/15/2021\n\n3 contributors Feedback\n\nIn this article\n\nThe kernel of an operating system implements the core functionality that everything else in the operating system depends upon. The Microsoft Windows kernel provides basic low-level operations such as scheduling threads or routing hardware interrupts. It is the heart of the operating system and all tasks it performs must be fast and simple.\n\nRoutines that provide a direct interface to the kernel library are usually prefixed with \"Ke\", for example, KeGetCurrentThread. For a list of kernel library routines, see Kernel Library Support Routines."}, {"url": "https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/_kernel/", "page_content": "_BitTest64\n\n\n\nThis topic describes the _BitTest64 function.\n\n_BitTestAndComplement64\n\n\n\nThis topic describes the _BitTestAndComplement64 function.\n\n_BitTestAndReset64\n\n\n\nThis topic describes the _BitTestAndReset64 function.\n\n_BitTestAndSet64\n\n\n\nThis topic describes the _BitTestAndSet64 function.\n\n_ReadWriteBarrier\n\n\n\nDescribes the ReadWriteBarrier~r1 function (miniport.h).\n\n_ReadWriteBarrier\n\n\n\nDescribes the ReadWriteBarrier~r2 function (wdm.h).\n\n_WHEA_SIGNAL_HANDLER_OVERRIDE_CALLBACK\n\n\n\nThis topic describes the _WHEA_SIGNAL_HANDLER_OVERRIDE_CALLBACK callback function.\n\nALLOCATE_FUNCTION_EX\n\n\n\nThe LookasideListAllocateEx routine allocates the storage for a new lookaside-list entry when a client requests an entry from a lookaside list that is empty.\n\nAppendTailList\n\n\n\nThe AppendTailList routine appends a doubly linked list of LIST_ENTRY structures to the tail of another doubly linked list of LIST_ENTRY structures.\n\nARM64_SYSREG_CRM\n\n\n\nReturns the CRn field for a given ARM system register.\n\nARM64_SYSREG_CRN\n\n\n\nLearn how the method returns the CRn field for a given ARM system register.\n\nARM64_SYSREG_OP1\n\n\n\nReturns the op1 field for a given ARM system register.\n\nARM64_SYSREG_OP2\n\n\n\nReturns the op2 field for a given ARM system register.\n\nAuxKlibEnumerateSystemFirmwareTables\n\n\n\nThe AuxKlibEnumerateSystemFirmwareTables routine enumerates all system firmware tables of the specified type.\n\nAuxKlibGetBugCheckData\n\n\n\nThe AuxKlibGetBugCheckData routine retrieves information about a bug check that has just occurred.\n\nAuxKlibGetImageExportDirectory\n\n\n\nThe AuxKlibGetImageExportDirectory routine returns an image module's export directory.\n\nAuxKlibGetSystemFirmwareTable\n\n\n\nThe AuxKlibGetSystemFirmwareTable routine retrieves the specified firmware table from the firmware table provider.\n\nAuxKlibInitialize\n\n\n\nThe AuxKlibInitialize routine initializes the Auxiliary Kernel-Mode Library.\n\nAuxKlibQueryModuleInformation\n\n\n\nThe AuxKlibQueryModuleInformation routine retrieves information about the image modules that the operating system has loaded.\n\nBarrierAfterRead\n\n\n\nDescribes the BarrierAfterRead function (miniport.h).\n\nBarrierAfterRead\n\n\n\nDescribes the BarrierAfterRead~r1 (miniport.h) function.\n\nBarrierAfterRead\n\n\n\nDescribes the BarrierAfterRead~r2 function (miniport.h).\n\nBarrierAfterRead\n\n\n\nDescribes the BarrierAfterRead function (wdm.h).\n\nBarrierAfterRead\n\n\n\nDescribes the BarrierAfterRead~r1 function (wdm.h).\n\nBarrierAfterRead\n\n\n\nDescribes the BarrierAfterRead~r2 function (wdm.h).\n\nBOOT_DRIVER_CALLBACK_FUNCTION\n\n\n\nLearn more about: BOOT_DRIVER_CALLBACK_FUNCTION callback function\n\nBOUND_CALLBACK\n\n\n\nThe BoundCallback routine is executed whenever the system issues a bounds exception for a user-mode thread.\n\nClfsAddLogContainer\n\n\n\nThe ClfsAddLogContainer routine adds a container to a CLFS log.\n\nClfsAddLogContainerSet\n\n\n\nThe ClfsAddLogContainerSet routine atomically adds a set of containers to a CLFS log.\n\nClfsAdvanceLogBase\n\n\n\nThe ClfsAdvanceLogBase routine sets the base LSN of a CLFS stream.\n\nClfsAlignReservedLog\n\n\n\nThe ClfsAlignReservedLog routine calculates the size of the space that must be reserved for a specified set of records. The size calculation includes the space required for headers and the space required for sector alignment.\n\nClfsAllocReservedLog\n\n\n\nThe ClfsAllocReservedLog routine reserves space in a marshalling area for a set of records.\n\nClfsCloseAndResetLogFile\n\n\n\nThe ClfsCloseAndResetLogFile routine releases all references to a specified log file object and marks its associated stream for reset.\n\nClfsCloseLogFileObject\n\n\n\nThe ClfsCloseLogFileObject routine releases all references to a log file object.\n\nClfsCreateLogFile\n\n\n\nThe ClfsCreateLogFile routine creates or opens a CLFS stream. If necessary, ClfsCreateLogFile also creates the underlying physical log that holds the stream's records.\n\nClfsCreateMarshallingArea\n\n\n\nThe ClfsCreateMarshallingArea routine creates a marshalling area for a CLFS stream and returns a pointer to an opaque context that represents the new marshalling area.\n\nClfsCreateScanContext\n\n\n\nThe ClfsCreateScanContext routine creates a scan context that can be used to iterate over the containers of a specified CLFS log.\n\nClfsDeleteLogByPointer\n\n\n\nThe ClfsDeleteLogByPointer routine marks a CLFS stream for deletion.\n\nClfsDeleteLogFile\n\n\n\nThe ClfsDeleteLogFile routine marks a CLFS stream for deletion.\n\nClfsDeleteMarshallingArea\n\n\n\nThe ClfsDeleteMarshallingArea routine deletes a marshalling area.\n\nClfsFlushBuffers\n\n\n\nThe ClfsFlushBuffers routine forces all log I/O blocks in a specified marshalling area to stable storage.\n\nClfsFlushToLsn\n\n\n\nThe ClfsFlushToLsn routine forces, to stable storage, all records that have an LSN less than or equal to a specified LSN.\n\nClfsGetContainerName\n\n\n\nThe ClfsGetContainerName routine returns the path name of a specified container.\n\nClfsGetIoStatistics\n\n\n\nThe ClfsGetIoStatistics routine returns I/O statistics for a specified CLFS log.\n\nClfsLsnBlockOffset\n\n\n\nThe ClfsLsnBlockOffset routine returns the sector-aligned block offset contained in a specified LSN.\n\nClfsLsnContainer\n\n\n\nThe ClfsLsnContainer routine returns the logical container identifier contained in a specified LSN.\n\nClfsLsnCreate\n\n\n\nThe ClfsLsnCreate routine creates a log sequence number (LSN), given a container identifier, a block offset, and a record sequence number.\n\nClfsLsnEqual\n\n\n\nThe ClfsLsnEqual routine determines whether two LSNs from the same stream are equal.\n\nClfsLsnGreater\n\n\n\nThe ClfsLsnGreater routine determines whether one LSN is greater than another LSN. The two LSNs must be from the same stream.\n\nClfsLsnLess\n\n\n\nThe ClfsLsnLess routine determines whether one LSN is less than another LSN. The two LSNs must be from the same stream.\n\nClfsLsnNull\n\n\n\nThe ClfsLsnNull routine determines whether a specified LSN is equal to the smallest possible LSN, CLFS_LSN_NULL.\n\nClfsLsnRecordSequence\n\n\n\nThe ClfsLsnRecordSequence routine returns the record sequence number contained in a specified LSN.\n\nClfsMgmtDeregisterManagedClient\n\n\n\nThe ClfsMgmtDeregisterManagedClient routine removes the connection between a client and a log, so that the client no longer manages the log.\n\nClfsMgmtHandleLogFileFull\n\n\n\nThe ClfsMgmtHandleLogFileFull routine attempts to make more space available in a log. It might make more space available by adding containers to the log, or it might ask clients to move their log tails.\n\nClfsMgmtInstallPolicy\n\n\n\nThe ClfsMgmtInstallPolicy routine adds a CLFS_MGMT_POLICY structure to a physical log.\n\nClfsMgmtQueryPolicy\n\n\n\nThe ClfsMgmtQueryPolicy routine retrieves a specific CLFS_MGMT_POLICY structure for a log.\n\nClfsMgmtRegisterManagedClient\n\n\n\nThe ClfsMgmtRegisterManagedClient routine creates a client that will manage a CLFS log.\n\nClfsMgmtRemovePolicy\n\n\n\nThe ClfsMgmtRemovePolicy routine resets a log's CLFS_MGMT_POLICY structure to its default value.\n\nClfsMgmtSetLogFileSize\n\n\n\nThe ClfsMgmtSetLogFileSize routine adds containers to a log or deletes containers from a log.\n\nClfsMgmtSetLogFileSizeAsClient\n\n\n\nThe ClfsMgmtSetLogFileSizeAsClient routine sets the log file size by adding containers to a client log or deleting containers from a client log.\n\nClfsMgmtTailAdvanceFailure\n\n\n\nThe ClfsMgmtTailAdvanceFailure routine notifies CLFS management that the client could not advance the log's tail.\n\nClfsQueryLogFileInformation\n\n\n\nThe ClfsQueryLogFileInformation routine returns metadata and state information for a specified CLFS stream or its underlying physical log or both.\n\nClfsReadLogRecord\n\n\n\nThe ClfsReadLogRecord routine reads a target record in a CLFS stream and returns a read context that the caller can use to read the records preceding or following it in the stream.\n\nClfsReadNextLogRecord\n\n\n\nThe ClfsReadNextLogRecord routine reads the next record in a sequence, relative to the current record in a read context.\n\nClfsReadPreviousRestartArea\n\n\n\nThe ClfsReadPreviousRestartArea routine reads the previous restart record relative to the current record in a read context.\n\nClfsReadRestartArea\n\n\n\nThe ClfsReadRestartArea routine reads the restart record that was most recently written to a specified CLFS stream.\n\nClfsRemoveLogContainer\n\n\n\nThe ClfsRemoveLogContainer routine removes a container from a CLFS log.\n\nClfsRemoveLogContainerSet\n\n\n\nThe ClfsRemoveLogContainerSet routine atomically removes a set of containers from a CLFS log.\n\nClfsReserveAndAppendLog\n\n\n\nThe ClfsReserveAndAppendLog routine reserves space in a marshalling area or appends a record to a marshalling area or does both atomically.\n\nClfsReserveAndAppendLogAligned\n\n\n\nThe ClfsReserveAndAppendLogAligned routine reserves space in a marshalling area or appends a record to a marshalling area or does both atomically. The record's data is aligned on specified boundaries.\n\nClfsScanLogContainers\n\n\n\nThe ClfsScanLogContainers routine retrieves descriptive information for a sequence of containers that belong to a particular CLFS log.\n\nClfsSetArchiveTail\n\n\n\nThe ClfsSetArchiveTail routine sets the archive tail of a CLFS log to a specified LSN.\n\nClfsSetEndOfLog\n\n\n\nThe ClfsSetEndOfLog routine truncates a CLFS stream.\n\nClfsSetLogFileInformation\n\n\n\nThe ClfsSetLogFileInformation routine sets metadata and state information for a specified stream and its underlying physical log.\n\nClfsTerminateReadLog\n\n\n\nThe ClfsTerminateReadLog routine invalidates a specified read context after freeing resources associated with the context.\n\nClfsWriteRestartArea\n\n\n\nThe ClfsWriteRestartArea routine atomically appends a new restart record to a CLFS stream, flushes the restart record to stable storage, and optionally updates the base LSN of the stream.\n\nCmCallbackGetKeyObjectID\n\n\n\nThe CmCallbackGetKeyObjectID routine retrieves the unique identifier and object name that are associated with a specified registry key object.\n\nCmCallbackGetKeyObjectIDEx\n\n\n\nThe CmCallbackGetKeyObjectIDEx routine retrieves the unique identifier and object name that are associated with a specified registry key object.\n\nCmCallbackReleaseKeyObjectIDEx\n\n\n\nThe CmCallbackReleaseKeyObjectIDEx routine frees an object name string obtained from the CmCallbackGetKeyObjectIDEx routine.\n\nCmGetBoundTransaction\n\n\n\nThe CmGetBoundTransaction routine returns a pointer to the transaction object that represents the transaction, if any, that is associated with a specified registry key object.\n\nCmGetCallbackVersion\n\n\n\nThe CmGetCallbackVersion routine retrieves the major and minor version numbers for the current version of the configuration manager's registry callback feature.\n\nCmRegisterCallback\n\n\n\nThe CmRegisterCallback routine is obsolete for Windows Vista and later operating system versions. Use CmRegisterCallbackEx instead.The CmRegisterCallback routine registers a RegistryCallback routine.\n\nCmRegisterCallbackEx\n\n\n\nThe CmRegisterCallbackEx routine registers a RegistryCallback routine.\n\nCmSetCallbackObjectContext\n\n\n\nThe CmSetCallbackObjectContext routine associates specified context information with a specified registry object.\n\nCmUnRegisterCallback\n\n\n\nThe CmUnRegisterCallback routine unregisters a RegistryCallback routine that a CmRegisterCallback or CmRegisterCallbackEx routine previously registered.\n\nCUSTOM_SYSTEM_EVENT_TRIGGER_INIT\n\n\n\nInitializes the CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG structure.\n\nD3COLD_REQUEST_AUX_POWER\n\n\n\nEnables the function device object (FDO) to convey its auxiliary power requirement.\n\nD3COLD_REQUEST_CORE_POWER_RAIL\n\n\n\nEnables the function device object (FDO) to indicate whether the core power rail is needed.\n\nD3COLD_REQUEST_PERST_DELAY\n\n\n\nEnables the function device object (FDO) to convey its requirement for a fixed delay time.\n\nDEVICE_QUERY_BUS_SPECIFIC_RESET_HANDLER\n\n\n\nThis topic describes the DEVICE_QUERY_BUS_SPECIFIC_RESET_HANDLER callback function.\n\nDEVICE_RESET_HANDLER\n\n\n\nThe DeviceReset routine is used to reset and recover a malfunctioning device.\n\nDMA_COMPLETION_ROUTINE\n\n\n\nThe DmaCompletionRoutine callback routine notifies the driver that previously requested a system DMA transfer that this transfer is complete.\n\nDRIVER_ADD_DEVICE\n\n\n\nThe AddDevice routine is responsible for creating functional device objects (FDO) or filter device objects (filter DO) for devices enumerated by the Plug and Play (PnP) manager.\n\nDRIVER_CANCEL\n\n\n\nThe Cancel routine cancels an I/O operation.\n\nDRIVER_CONTROL\n\n\n\nThis routine starts a DMA data-transfer or a data transfer operation.\n\nDRIVER_DISPATCH\n\n\n\nThe callback routine services various IRPs. For a list of function codes, see Remarks.\n\nDRIVER_INITIALIZE\n\n\n\nDriverEntry is the first routine called after a driver is loaded, and is responsible for initializing the driver.\n\nDRIVER_LIST_CONTROL\n\n\n\nThe AdapterListControl routine starts a direct memory access (DMA) scatter/gather operation.\n\nDRIVER_REINITIALIZE\n\n\n\nThe Reinitialize routine continues driver and device initialization after the driver's DriverEntry routine returns.\n\nDRIVER_STARTIO\n\n\n\nThe StartIo routine starts the I/O operation described by an IRP.\n\nDRIVER_UNLOAD\n\n\n\nThe Unload routine performs any operations that are necessary before the system unloads the driver.\n\nEtwSetInformation\n\n\n\nThe EtwSetInformation provides special-purpose information to modify a kernel-mode ETW provider registration.\n\nEX_CALLBACK_FUNCTION\n\n\n\nA filter driver's RegistryCallback routine can monitor, block, or modify a registry operation.\n\nExAcquireFastMutex\n\n\n\nLearn more about the ExAcquireFastMutex routine.\n\nExAcquireFastMutexUnsafe\n\n\n\nLearn more about the ExAcquireFastMutexUnsafe routine.\n\nExAcquirePushLockExclusive\n\n\n\nAcquires the given push lock for exclusive access by the calling thread.\n\nExAcquirePushLockShared\n\n\n\nAcquires the given push lock for shared access by the calling thread.\n\nExAcquireResourceExclusiveLite\n\n\n\nThe ExAcquireResourceExclusiveLite routine acquires the given resource for exclusive access by the calling thread.\n\nExAcquireResourceSharedLite\n\n\n\nThe ExAcquireResourceSharedLite routine acquires the given resource for shared access by the calling thread.\n\nExAcquireRundownProtection\n\n\n\nThe ExAcquireRundownProtection routine tries to acquire run-down protection on a shared object so the caller can safely access the object.\n\nExAcquireRundownProtectionCacheAware\n\n\n\nThis topic describes the ExAcquireRundownProtectionCacheAware function.\n\nExAcquireRundownProtectionCacheAwareEx\n\n\n\nThis topic describes the ExAcquireRundownProtectionCacheAwareEx function.\n\nExAcquireRundownProtectionEx\n\n\n\nThe ExAcquireRundownProtectionEx routine tries to acquire run-down protection on a shared object so the caller can safely access the object.\n\nExAcquireSharedStarveExclusive\n\n\n\nThe ExAcquireSharedStarveExclusive routine acquires a given resource for shared access without waiting for any pending attempts to acquire exclusive access to the same resource.\n\nExAcquireSharedWaitForExclusive\n\n\n\nThe ExAcquireSharedWaitForExclusive routine acquires the given resource for shared access if shared access can be granted and there are no exclusive waiters.\n\nExAcquireSpinLockExclusive\n\n\n\nThe ExAcquireSpinLockExclusive routine acquires a spin lock for exclusive access by the caller, and raises the IRQL to DISPATCH_LEVEL.\n\nExAcquireSpinLockExclusiveAtDpcLevel\n\n\n\nLearn more about the ExAcquireSpinLockExclusiveAtDpcLevel routine.\n\nExAcquireSpinLockShared\n\n\n\nThe ExAcquireSpinLockShared routine acquires a spin lock for shared access by the caller, and raises the IRQL to DISPATCH_LEVEL.\n\nExAcquireSpinLockSharedAtDpcLevel\n\n\n\nLearn more about the ExAcquireSpinLockSharedAtDpcLevel routine.\n\nExAllocateCacheAwareRundownProtection\n\n\n\nThis topic describes the ExAllocateCacheAwareRundownProtection function.\n\nExAllocateFromLookasideListEx\n\n\n\nThe ExAllocateFromLookasideListEx routine removes the first entry from the specified lookaside list, or, if the list is empty, dynamically allocates the storage for a new entry.\n\nExAllocateFromNPagedLookasideList\n\n\n\nThe ExAllocateFromNPagedLookasideList routine returns a pointer to a nonpaged entry from the given lookaside list, or it returns a pointer to a newly allocated nonpaged entry.\n\nExAllocateFromPagedLookasideList\n\n\n\nThe ExAllocateFromPagedLookasideList routine returns a pointer to a paged entry from the given lookaside list, or it returns a pointer to a newly allocated paged entry.\n\nExAllocatePool\n\n\n\nThe ExAllocatePool routine is obsolete, and is exported only for existing binaries. Use ExAllocatePoolWithTag instead. ExAllocatePool allocates pool memory.\n\nExAllocatePool2\n\n\n\nLearn more about: ExAllocatePool2\n\nExAllocatePool3\n\n\n\nLearn more about: ExAllocatePool3\n\nExAllocatePoolPriorityUninitialized\n\n\n\nExAllocatePoolPriorityUninitialized allocates pool memory of the specified type. This routine is a wrapper and replacement option for ExAllocatePoolWithTagPriority.\n\nExAllocatePoolPriorityZero\n\n\n\nLearn more about: ExAllocatePoolPriorityZero\n\nExAllocatePoolQuotaUninitialized\n\n\n\nThe ExAllocatePoolQuotaUninitialized routine allocates pool memory, charging the quota against the current process.\n\nExAllocatePoolQuotaZero\n\n\n\nLearn more about: ExAllocatePoolQuotaZero\n\nExAllocatePoolUninitialized\n\n\n\nThis routine is a wrapper and replacement option for ExAllocatePoolWithTag.\n\nExAllocatePoolWithQuota\n\n\n\nObsolete. Use ExAllocatePoolWithQuotaTag instead. ExAllocatePoolWithQuota allocates pool memory. It is exported only for existing driver binaries.\n\nExAllocatePoolWithQuotaTag\n\n\n\nThe ExAllocatePoolWithQuotaTag routine allocates pool memory, charging the quota against the current process.\n\nExAllocatePoolWithTag\n\n\n\nObsolete. Use ExAllocatePool2 instead. The ExAllocatePoolWithTag routine allocates pool memory of the specified type and returns a pointer to the allocated block.\n\nExAllocatePoolWithTagPriority\n\n\n\nThe ExAllocatePoolWithTagPriority routine allocates pool memory of the specified type.\n\nExAllocatePoolZero\n\n\n\nLearn more about: ExAllocatePoolZero\n\nExAllocateTimer\n\n\n\nThe ExAllocateTimer routine allocates and initializes a timer object.\n\nExCancelTimer\n\n\n\nThe ExCancelTimer routine cancels a timer that was set by a previous call to the ExSetTimer routine.\n\nExConvertExclusiveToSharedLite\n\n\n\nThe ExConvertExclusiveToSharedLite routine converts a given resource from acquired for exclusive access to acquired for shared access.\n\nExCreateCallback\n\n\n\nThe ExCreateCallback routine either creates a new callback object or opens an existing callback object on behalf of the caller.\n\nExCreatePool\n\n\n\nDefines the ExCreatePool function.\n\nExDeleteLookasideListEx\n\n\n\nThe ExDeleteLookasideListEx routine deletes a lookaside list.\n\nExDeleteNPagedLookasideList\n\n\n\nThe ExDeleteNPagedLookasideList routine destroys a nonpaged lookaside list.\n\nExDeletePagedLookasideList\n\n\n\nThe ExDeletePagedLookasideList routine destroys a paged lookaside list.\n\nExDeleteResourceLite\n\n\n\nThe ExDeleteResourceLite routine deletes a given resource from the system's resource list.\n\nExDeleteTimer\n\n\n\nThe ExDeleteTimer routine deletes a timer object that was previously allocated by the ExAllocateTimer routine.\n\nExDestroyPool\n\n\n\nDefines the ExDestroyPool function.\n\nExEnterCriticalRegionAndAcquireResourceExclusive\n\n\n\nLearn more about the ExEnterCriticalRegionAndAcquireResourceExclusive routine.\n\nExFlushLookasideListEx\n\n\n\nThe ExFlushLookasideListEx routine flushes all entries from the specified lookaside list and frees the allocated storage for each entry.\n\nExFreeCacheAwareRundownProtection\n\n\n\nThis topic describes the ExFreeCacheAwareRundownProtection function.\n\nExFreePool\n\n\n\nThe ExFreePool macro (ntddk.h) routine deallocates a specified block of pool memory that was previously allocated.\n\nExFreePool\n\n\n\nThe ExFreePool function (wdm.h) deallocates a specified block of pool memory that was previously allocated.\n\nExFreePool2\n\n\n\nDefines the ExFreePool2 function.\n\nExFreePoolWithTag\n\n\n\nThe ExFreePoolWithTag routine deallocates a block of pool memory allocated with the specified tag.\n\nExFreeToLookasideListEx\n\n\n\nThe ExFreeToLookasideListEx routine inserts an entry into a lookaside list, or, if the list is full, frees the allocated storage for the entry.\n\nExFreeToNPagedLookasideList\n\n\n\nThe ExFreeToNPagedLookasideList routine returns a nonpaged entry to the given lookaside list or to nonpaged pool.\n\nExFreeToPagedLookasideList\n\n\n\nThe ExFreeToPagedLookasideList routine returns a pageable entry to the given lookaside list or to paged pool.\n\nExGetExclusiveWaiterCount\n\n\n\nThe ExGetExclusiveWaiterCount routine returns the number of waiters on exclusive access to a given resource.\n\nExGetFirmwareEnvironmentVariable\n\n\n\nThe ExGetFirmwareEnvironmentVariable routine gets the value of the specified system firmware environment variable.\n\nExGetFirmwareType\n\n\n\nReturns the system firmware type.\n\nExGetPreviousMode\n\n\n\nThe ExGetPreviousMode routine returns the previous processor mode for the current thread.\n\nExGetSharedWaiterCount\n\n\n\nThe ExGetSharedWaiterCount routine returns the number of waiters on shared access to a given resource.\n\nExInitializeDeleteTimerParameters\n\n\n\nThe ExInitializeDeleteTimerParameters routine initializes an EXT_DELETE_PARAMETERS structure.\n\nExInitializeDeviceAts\n\n\n\nDescribes the ExInitializeDeviceAts function.\n\nExInitializeDriverRuntime\n\n\n\nLearn more about: ExInitializeDriverRuntime\n\nExInitializeFastMutex\n\n\n\nThe ExInitializeFastMutex routine initializes a fast mutex variable, used to synchronize mutually exclusive access by a set of threads to a shared resource.\n\nExInitializeLookasideListEx\n\n\n\nThe ExInitializeLookasideListEx routine initializes a lookaside list.\n\nExInitializeNPagedLookasideList\n\n\n\nThe ExInitializeNPagedLookasideList routine initializes a lookaside list for nonpaged entries of the specified size.\n\nExInitializePagedLookasideList\n\n\n\nThe ExInitializePagedLookasideList routine initializes a lookaside list for pageable entries of the specified size.\n\nExInitializePushLock\n\n\n\nInitializes a push lock variable.\n\nExInitializeResourceLite\n\n\n\nThe ExInitializeResourceLite routine initializes a resource variable.\n\nExInitializeRundownProtection\n\n\n\nThe ExInitializeRundownProtection routine initializes run-down protection on a shared object.\n\nExInitializeRundownProtectionCacheAware\n\n\n\nThis topic describes the ExInitializeRundownProtectionCacheAware function.\n\nExInitializeSetTimerParameters\n\n\n\nThe ExInitializeSetTimerParameters routine initializes an EXT_SET_PARAMETERS structure.\n\nExInterlockedAddLargeInteger\n\n\n\nThe ExInterlockedAddLargeInteger routine adds a large integer value to the specified variable as an atomic operation.\n\nExInterlockedAddLargeStatistic\n\n\n\nThe ExInterlockedAddLargeStatistic routine performs an interlocked addition of a ULONG increment value to a LARGE_INTEGER variable.\n\nExInterlockedAddUlong\n\n\n\nThe ExInterlockedAddUlong routine adds an unsigned long value to a given unsigned integer as an atomic operation.\n\nExInterlockedCompareExchange64\n\n\n\nThe ExInterlockedCompareExchange64 routine compares one integer variable to another and, if they are equal, sets the first variable to a caller-supplied value.\n\nExInterlockedFlushSList\n\n\n\nThe ExInterlockedFlushSList routine atomically removes all entries from a sequenced singly linked list.\n\nExInterlockedInsertHeadList\n\n\n\nThe ExInterlockedInsertHeadList routine atomically inserts an entry at the beginning of a doubly linked list of LIST_ENTRY structures.\n\nExInterlockedInsertTailList\n\n\n\nThe ExInterlockedInsertTailList routine atomically inserts an entry at the end of a doubly linked list of LIST_ENTRY structures.\n\nExInterlockedPopEntryList\n\n\n\nThe ExInterlockedPopEntryList routine atomically removes an entry from the beginning of a singly linked list of SINGLE_LIST_ENTRY structures.\n\nExInterlockedPopEntrySList\n\n\n\nThe ExInterlockedPopEntrySList routine atomically removes the first entry from a sequenced singly linked list.\n\nExInterlockedPushEntryList\n\n\n\nThe ExInterlockedPushEntryList routine atomically inserts an entry at the beginning of a singly linked list of SINGLE_LIST_ENTRY structures.\n\nExInterlockedPushEntrySList\n\n\n\nThe ExInterlockedPushEntrySList routine atomically inserts an entry at the beginning of a sequenced singly linked list.\n\nExInterlockedRemoveHeadList\n\n\n\nThe ExInterlockedRemoveHeadList routine removes an entry from the beginning of a doubly linked list of LIST_ENTRY structures.\n\nExIsProcessorFeaturePresent\n\n\n\nThe ExIsProcessorFeaturePresent routine queries for the existence of a specified processor feature.\n\nExIsResourceAcquiredExclusiveLite\n\n\n\nThe ExIsResourceAcquiredExclusiveLite routine returns whether the current thread has exclusive access to a given resource.\n\nExIsResourceAcquiredSharedLite\n\n\n\nThe ExIsResourceAcquiredSharedLite routine returns whether the current thread has access (either shared or exclusive) to a given resource.\n\nExIsSoftBoot\n\n\n\nDetermines whether the system has gone through a soft restart.\n\nExLocalTimeToSystemTime\n\n\n\nThe ExLocalTimeToSystemTime routine converts a system time value for the current time zone to an unbiased, GreenGMT value.\n\nExNotifyCallback\n\n\n\nThe ExNotifyCallback routine causes all callback routines registered for the given object to be called.\n\nEXPAND_STACK_CALLOUT\n\n\n\nThe ExpandedStackCall routine executes with a guaranteed stack size.\n\nExpInterlockedPopEntrySList\n\n\n\nDescribes the ExpInterlockedPopEntrySList function.\n\nExpInterlockedPushEntrySList\n\n\n\nDescribes the ExpInterlockedPushEntrySList function.\n\nExQueryDepthSList\n\n\n\nThe ExQueryDepthSList routine returns the number of entries currently in a given sequenced singly linked list.\n\nExQueryTimerResolution\n\n\n\nThe ExQueryTimerResolution routine reports the range of timer resolutions that are supported by the system clock.\n\nExRaiseAccessViolation\n\n\n\nThe ExRaiseAccessViolation routine can be used with structured exception handling to throw a driver-determined exception for a memory access violation that occurs when a driver processes I/O requests.\n\nExRaiseDatatypeMisalignment\n\n\n\nThe ExRaiseDatatypeMisalignment routine can be used with structured exception handling to throw a driver-determined exception for a misaligned data type that occurs when a driver processes I/O requests.\n\nExRaiseStatus\n\n\n\nThe ExRaiseStatus routine is called by drivers that supply structured exception handlers to handle particular errors that occur while they are processing I/O requests.\n\nExRegisterCallback\n\n\n\nThe ExRegisterCallback routine registers a given callback routine with a given callback object.\n\nExReinitializeResourceLite\n\n\n\nThe ExReinitializeResourceLite routine reinitializes an existing resource variable.\n\nExReInitializeRundownProtection\n\n\n\nThe ExReInitializeRundownProtection routine reinitializes an EX_RUNDOWN_REF structure after the associated object is run down.\n\nExReInitializeRundownProtectionCacheAware\n\n\n\nThis topic describes the ExReInitializeRundownProtectionCacheAware function.\n\nExReleaseFastMutex\n\n\n\nLearn more about the ExReleaseFastMutex routine.\n\nExReleaseFastMutexUnsafe\n\n\n\nLearn more about the ExReleaseFastMutexUnsafe routine.\n\nExReleasePushLockExclusive\n\n\n\nReleases a specified push lock for exclusive access owned by the current thread.\n\nExReleasePushLockShared\n\n\n\nReleases a specified push lock for shared access owned by the current thread.\n\nExReleaseResourceAndLeaveCriticalRegion\n\n\n\nLearn more about the ExReleaseResourceAndLeaveCriticalRegion routine.\n\nExReleaseResourceForThreadLite\n\n\n\nThe ExReleaseResourceForThreadLite routine releases the input resource of the indicated thread.\n\nExReleaseResourceLite\n\n\n\nThe ExReleaseResourceLite routine releases a specified executive resource owned by the current thread.\n\nExReleaseRundownProtection\n\n\n\nThe ExReleaseRundownProtection routine releases run-down protection that the caller previously acquired by calling the ExAcquireRundownProtection routine.\n\nExReleaseRundownProtectionCacheAware\n\n\n\nThis topic describes the ExReleaseRundownProtectionCacheAware function.\n\nExReleaseRundownProtectionCacheAwareEx\n\n\n\nThis topic describes the ExReleaseRundownProtectionCacheAwareEx function.\n\nExReleaseRundownProtectionEx\n\n\n\nThe ExReleaseRundownProtectionEx routine releases run-down protection that the caller previously acquired by calling the ExAcquireRundownProtectionEx routine.\n\nExReleaseSpinLockExclusive\n\n\n\nThe ExReleaseSpinLockExclusive routine releases a spin lock that the caller previously acquired for exclusive access, and restores the IRQL to its original value.\n\nExReleaseSpinLockExclusiveFromDpcLevel\n\n\n\nLearn more about the ExReleaseSpinLockExclusiveFromDpcLevel routine.\n\nExReleaseSpinLockShared\n\n\n\nThe ExReleaseSpinLockShared routine releases ownership of a spin lock that the caller previously acquired for shared access, and restores the IRQL to its original value.\n\nExReleaseSpinLockSharedFromDpcLevel\n\n\n\nLearn more about the ExReleaseSpinLockSharedFromDpcLevel routine.\n\nExRundownCompleted\n\n\n\nThe ExRundownCompleted routine updates the run-down status of a shared object to indicate that the run down of the object has completed.\n\nExRundownCompletedCacheAware\n\n\n\nThis topic describes the ExRundownCompletedCacheAware function.\n\nExSecurePoolUpdate\n\n\n\nThe ExSecurePoolUpdate function updates the contents of the secure pool allocation.\n\nExSecurePoolValidate\n\n\n\nThe ExSecurePoolValidate function validates that the secure pool provided is indeed the one previously created.\n\nExSetFirmwareEnvironmentVariable\n\n\n\nThe ExSetFirmwareEnvironmentVariable routine sets the value of the specified system firmware environment variable.\n\nExSetResourceOwnerPointer\n\n\n\nThe ExSetResourceOwnerPointer routine sets the owner thread pointer for an executive resource.\n\nExSetResourceOwnerPointerEx\n\n\n\nThe ExSetResourceOwnerPointerEx routine transfers the ownership of an executive resource from the calling thread to an owner pointer, which is a system address that identifies the resource owner.\n\nExSetTimer\n\n\n\nThe ExSetTimer routine starts a timer operation and sets the timer to expire at the specified due time.\n\nExSetTimerResolution\n\n\n\nThe ExSetTimerResolution routine modifies the frequency at which the system clock interrupts. Use this routine with extreme caution (see the following Remarks section).\n\nExSizeOfRundownProtectionCacheAware\n\n\n\nThis topic describes the ExSizeOfRundownProtectionCacheAware function.\n\nExSystemTimeToLocalTime\n\n\n\nThe ExSystemTimeToLocalTime routine converts a GMT system time value to the local system time for the current time zone.\n\nEXT_CALLBACK\n\n\n\nAn ExTimerCallback callback routine runs after an EX_TIMER timer object's time interval expires.\n\nEXT_DELETE_CALLBACK\n\n\n\nAn ExTimerDeleteCallback callback routine runs when the operating system deletes an EX_TIMER timer object.\n\nExTryAcquirePushLockExclusive\n\n\n\nDescribes the ExTryAcquirePushLockExclusive macro.\n\nExTryAcquirePushLockShared\n\n\n\nDescribes the ExTryAcquirePushLockShared macro.\n\nExTryConvertSharedSpinLockExclusive\n\n\n\nThe ExTryConvertSharedSpinLockExclusive routine attempts to convert the access state of a spin lock from acquired for shared access to exclusive access.\n\nExTryToAcquireFastMutex\n\n\n\nLearn more about the ExTryToAcquireFastMutex routine.\n\nExUnregisterCallback\n\n\n\nThe ExUnregisterCallback routine removes a callback routine previously registered with a callback object from the list of routines to be called during the notification process.\n\nExUuidCreate\n\n\n\nThe ExUuidCreate routine initializes a UUID (GUID) structure to a newly generated value.\n\nExWaitForRundownProtectionRelease\n\n\n\nThe ExWaitForRundownProtectionRelease routine waits until all drivers that have already been granted run-down protection complete their accesses of the shared object.\n\nExWaitForRundownProtectionReleaseCacheAware\n\n\n\nThis topic describes the ExWaitForRundownProtectionReleaseCacheAware function.\n\nFIELD_OFFSET\n\n\n\nThe FIELD_OFFSET macro (miniport.h) returns the byte offset of the specified field in the specified known structure type.\n\nFIELD_OFFSET\n\n\n\nThe FIELD_OFFSET macro (wdm.h) returns the byte offset of the specified field in the specified known structure type.\n\nFirstEntrySList\n\n\n\nThe FirstEntrySList routine returns the first entry in a sequenced singly linked list.\n\nFPGA_BUS_SCAN\n\n\n\nReserved for future use. Triggers a bus scan at the parent of the FPGA device.\n\nFPGA_CONTROL_CONFIG_SPACE\n\n\n\nReserved for future use. Enables or disables the access to the configuration space of the FPGA device.\n\nFPGA_CONTROL_ERROR_REPORTING\n\n\n\nReserved for future use. Toggles the error reporting for the FPGA device and its parent bridge.\n\nFPGA_CONTROL_LINK\n\n\n\nReserved for future use of FPGA_CONTROL_LINK.\n\nFREE_FUNCTION_EX\n\n\n\nThe LookasideListFreeEx routine frees the storage for a lookaside-list entry when a client tries to insert the entry into a lookaside list that is full.\n\nGET_D3COLD_CAPABILITY\n\n\n\nThe GetBusDriverD3ColdSupport routine enables the driver for a device to query whether the enumerating bus driver supports the D3cold device power state.\n\nGET_D3COLD_LAST_TRANSITION_STATUS\n\n\n\nThe GetLastTransitionStatus routine enables the driver for a device to query whether the most recent transition to the D3hot substate was followed by a transition to the D3cold substate.\n\nGET_DEVICE_RESET_STATUS\n\n\n\nThis topic describes the GET_DEVICE_RESET_STATUS callback function.\n\nGET_DMA_ADAPTER\n\n\n\nThe GetDmaAdapter routine returns a DMA_ADAPTER structure for the target device.\n\nGET_IDLE_WAKE_INFO\n\n\n\nThe GetIdleWakeInfo routine enables the driver for a device to discover the device power states from which the device can signal a wake event.\n\nGET_SDEV_IDENTIFIER\n\n\n\nThis material is not yet available. This placeholder topic is provided as an example of documentation that may be included in a later release.\n\nGET_SET_DEVICE_DATA\n\n\n\nThe GetBusData routine reads data from the device's configuration space.\n\nGET_UPDATED_BUS_RESOURCE\n\n\n\nReports the latest resource lists.\n\nHalAllocateHardwareCounters\n\n\n\nThe HalAllocateHardwareCounters routine allocates a set of hardware performance counters.\n\nHalExamineMBR\n\n\n\nThe HalExamineMBR function reads the master boot record (MBR) of a disk and returns the MBR data if the MBR is of the specified type.\n\nHalFreeHardwareCounters\n\n\n\nThe HalFreeHardwareCounters routine frees a set of hardware performance counters that was acquired in a previous call to HalAllocateHardwareCounters routine.\n\nHalGetBusDataByOffset\n\n\n\nThis function retrieves information, starting at the offset, about a slot or address on an I/O bus.\n\nHalSetBusDataByOffset\n\n\n\nThis function sets bus-configuration data for a device on a dynamically configurable I/O bus with a published, standard interface.\n\nIMAGE_POLICY_OVERRIDE\n\n\n\nReserved for the IMAGE_POLICY_OVERRIDE macro.\n\nInitializeListHead\n\n\n\nThe InitializeListHead routine initializes a LIST_ENTRY structure that represents the head of a doubly linked list.\n\nInitializeSListHead\n\n\n\nThe InitializeSListHead routine (or ExInitializeSListHead) initializes an SLIST_HEADER structure that represents the head of a sequenced singly linked list.\n\nInsertHeadList\n\n\n\nThe InsertHeadList routine inserts an entry at the head of a doubly linked list of LIST_ENTRY structures.\n\nInsertTailList\n\n\n\nThe InsertTailList routine inserts an entry at the tail of a doubly linked list of LIST_ENTRY structures.\n\nInterlockedAnd\n\n\n\nThe InterlockedAnd (miniport.h) macro atomically computes a bitwise AND operation with the specified variable and specified value.\n\nInterlockedAnd\n\n\n\nThe InterlockedAnd (wdm.h) macro atomically computes a bitwise AND operation with the specified variable and specified value.\n\nInterlockedCompareExchange\n\n\n\nThe InterlockedCompareExchange routine performs an atomic operation that compares the input value pointed to by Destination with the value of Comparand.\n\nInterlockedCompareExchange\n\n\n\nThe InterlockedCompareExchange routine performs an atomic operation that compares the input value pointed to by Destination with the value of Comperand.\n\nInterlockedCompareExchangePointer\n\n\n\nThe InterlockedCompareExchangePointer routine performs an atomic operation that compares the input pointer value pointed to by Destination with the pointer value Comparand.\n\nInterlockedCompareExchangePointer\n\n\n\nThe InterlockedCompareExchangePointer routine performs an atomic operation that compares the input pointer value pointed to by Destination with the pointer value Comperand.\n\nInterlockedDecrement\n\n\n\nThe InterlockedDecrement function (miniport.h) decrements a caller-supplied variable of type LONG as an atomic operation.\n\nInterlockedDecrement\n\n\n\nThe InterlockedDecrement function (wdm.h) decrements a caller-supplied variable of type LONG as an atomic operation.\n\nInterlockedExchange\n\n\n\nThe InterlockedExchange function (miniport.h) sets an integer variable to a given value as an atomic operation.\n\nInterlockedExchange\n\n\n\nThe InterlockedExchange function (wdm.h) sets an integer variable to a given value as an atomic operation.\n\nInterlockedExchangeAdd\n\n\n\nThe InterlockedExchangeAdd function (miniport.h) adds a value to a given integer as an atomic operation and returns the original value of the given integer.\n\nInterlockedExchangeAdd\n\n\n\nThe InterlockedExchangeAdd function (wdm.h) adds a value to a given integer as an atomic operation and returns the original value of the given integer.\n\nInterlockedExchangePointer\n\n\n\nThe InterlockedExchangePointer function (miniport.h) performs an atomic operation that sets a pointer to a new value.\n\nInterlockedExchangePointer\n\n\n\nThe InterlockedExchangePointer function (wdm.h) performs an atomic operation that sets a pointer to a new value.\n\nInterlockedIncrement\n\n\n\nThe InterlockedIncrement function (miniport.h) increments a caller-supplied variable as an atomic operation.\n\nInterlockedIncrement\n\n\n\nThe InterlockedIncrement function (wdm.h) increments a caller-supplied variable as an atomic operation.\n\nInterlockedOr\n\n\n\nThe InterlockedOr function (miniport.h) atomically computes a bitwise OR operation with the specified variable and specified value.\n\nInterlockedOr\n\n\n\nThe InterlockedOr function (wdm.h) atomically computes a bitwise OR operation with the specified variable and specified value.\n\nInterlockedXor\n\n\n\nThe InterlockedXor function (miniport.h) atomically computes a bitwise exclusive OR operation with the specified variable and specified value.\n\nInterlockedXor\n\n\n\nThe InterlockedXor function (wdm.h) atomically computes a bitwise exclusive OR operation with the specified variable and specified value.\n\nIO_COMPLETION_ROUTINE\n\n\n\nThe IoCompletion routine completes the processing of I/O operations.\n\nIO_CSQ_ACQUIRE_LOCK\n\n\n\nThe CsqAcquireLock routine is used by the system to acquire the lock for a driver-implemented, cancel-safe IRP queue.\n\nIO_CSQ_COMPLETE_CANCELED_IRP\n\n\n\nThe CsqCompleteCanceledIrp routine is used by the system to signal to the driver that it can complete a canceled IRP.\n\nIO_CSQ_INSERT_IRP\n\n\n\nThe CsqInsertIrp routine is used by the system to insert an IRP into a driver-implemented, cancel-safe IRP queue.\n\nIO_CSQ_INSERT_IRP_EX\n\n\n\nThe CsqInsertIrpEx routine is used by the system to insert an IRP into a driver-implemented, cancel-safe IRP queue.\n\nIO_CSQ_PEEK_NEXT_IRP\n\n\n\nThe CsqPeekNextIrp routine is used by the system to find the next matching IRP in a driver-implemented, cancel-safe IRP queue.\n\nIO_CSQ_RELEASE_LOCK\n\n\n\nThe CsqReleaseLock routine is used by the system to release the lock that was acquired using CsqAcquireLock.\n\nIO_CSQ_REMOVE_IRP\n\n\n\nThe CsqRemoveIrp routine is used by the system to remove the specified IRP from a driver-implemented, cancel-safe IRP queue.\n\nIO_DPC_ROUTINE\n\n\n\nThe DpcForIsr routine finishes the servicing of an I/O operation, after an InterruptService routine returns.\n\nIO_SESSION_NOTIFICATION_FUNCTION\n\n\n\nThe IO_SESSION_NOTIFICATION_FUNCTION function type defines a callback routine through which a driver receives notifications of changes in the state of user sessions that the driver is interested in.\n\nIO_TIMER_ROUTINE\n\n\n\nThe IoTimer routine is a DPC that, if registered, is called once per second.\n\nIO_WORKITEM_ROUTINE\n\n\n\nA WorkItem routine performs the processing for a work item that was queued by the IoQueueWorkItem routine.\n\nIO_WORKITEM_ROUTINE_EX\n\n\n\nA WorkItemEx routine performs the processing for a work item that was queued by the IoQueueWorkItemEx or IoTryQueueWorkItem routine.\n\nIoAcquireCancelSpinLock\n\n\n\nLearn more about the IoAcquireCancelSpinLock routine.\n\nIoAcquireKsrPersistentMemory\n\n\n\nMicrosoft reserves the IoAcquireKsrPersistentMemory function for internal use only. Don't use this function in your code.\n\nIoAcquireKsrPersistentMemoryEx\n\n\n\nMicrosoft reserves the IoAcquireKsrPersistentMemoryEx function for internal use only. Don't use this function in your code.\n\nIoAcquireRemoveLock\n\n\n\nThe IoAcquireRemoveLock routine increments the count for a remove lock, indicating that the associated device object should not be detached from the device stack or deleted.\n\nIoAdjustPagingPathCount\n\n\n\nThe IoAdjustPagingPathCount routine increments or decrements a caller-supplied page-file counter as an atomic operation.\n\nIoAllocateAdapterChannel\n\n\n\nDeprecated. Use PALLOCATE_ADAPTER_CHANNEL.\n\nIoAllocateController\n\n\n\nThe IoAllocateController routine sets up the call to a driver-supplied ControllerControl routine as soon as the device controller, represented by the given controller object, is available to carry out an I/O operation for the target device, represented by the given device object.\n\nIoAllocateDriverObjectExtension\n\n\n\nThe IoAllocateDriverObjectExtension routine allocates a per-driver context area, called a driver object extension, and assigns a unique identifier to it.\n\nIoAllocateErrorLogEntry\n\n\n\nThe IoAllocateErrorLogEntry routine allocates an error log entry, and returns a pointer to the packet that the caller uses to supply information about an I/O error.\n\nIoAllocateIrp\n\n\n\nThe IoAllocateIrp routine allocates an IRP, given the number of I/O stack locations for each driver layered under the caller, and, optionally, for the caller.\n\nIoAllocateIrpEx\n\n\n\nIoAllocateIrpEx allocates an I/O request packet (IRP) from\n\nIoAllocateMdl\n\n\n\nThe IoAllocateMdl routine allocates a memory descriptor list (MDL) large enough to map a buffer, given the buffer's starting address and length. Optionally, this routine associates the MDL with an IRP.\n\nIoAllocateWorkItem\n\n\n\nThe IoAllocateWorkItem routine allocates a work item.\n\nIoAssignArcName\n\n\n\nThe IoAssignArcName routine creates a symbolic link between the ARC name of a physical device and the name of the corresponding device object when it has been created.\n\nIoAttachDevice\n\n\n\nThe IoAttachDevice routine attaches the caller's device object to a named target device object, so that I/O requests bound for the target device are routed first to the caller.\n\nIoAttachDeviceToDeviceStack\n\n\n\nThe IoAttachDeviceToDeviceStack routine attaches the caller's device object to the highest device object in the chain and returns a pointer to the previously highest device object.\n\nIoBuildAsynchronousFsdRequest\n\n\n\nThe IoBuildAsynchronousFsdRequest routine allocates and sets up an IRP to be sent to lower-level drivers.\n\nIoBuildDeviceIoControlRequest\n\n\n\nThe IoBuildDeviceIoControlRequest routine allocates and sets up an IRP for a synchronously processed device control request.\n\nIoBuildPartialMdl\n\n\n\nThe IoBuildPartialMdl routine builds a new memory descriptor list (MDL) that represents part of a buffer that is described by an existing MDL.\n\nIoBuildSynchronousFsdRequest\n\n\n\nThe IoBuildSynchronousFsdRequest routine allocates and sets up an IRP for a synchronously processed I/O request.\n\nIoCallDriver\n\n\n\nThe IoCallDriver routine sends an IRP to the driver associated with a specified device object.\n\nIoCancelIrp\n\n\n\nThe IoCancelIrp routine sets the cancel bit in a given IRP and calls the cancel routine for the IRP if there is one.\n\nIoCheckFileObjectOpenedAsCopyDestination\n\n\n\nLearn more about the IoCheckFileObjectOpenedAsCopyDestination function.\n\nIoCheckFileObjectOpenedAsCopySource\n\n\n\nLearn more about the IoCheckFileObjectOpenedAsCopySource function.\n\nIoCheckLinkShareAccess\n\n\n\nThe IoCheckLinkShareAccess routine is called by file system drivers (FSDs) or other highest-level drivers to check whether link shared access to a file object is permitted.\n\nIoCheckShareAccess\n\n\n\nThe IoCheckShareAccess routine is called by file system drivers (FSDs) or other highest-level drivers to check whether shared access to a file object is permitted.\n\nIoCheckShareAccessEx\n\n\n\nThe IoCheckShareAccessEx routine is called by file system drivers (FSDs) or other highest-level drivers to check whether shared access to a file object is permitted.\n\nIoClearActivityIdThread\n\n\n\nThe IoClearActivityIdThread routine clears the activity ID of the current thread.\n\nIoConnectInterrupt\n\n\n\nThe IoConnectInterrupt routine registers a device driver's InterruptService routine (ISR), so that it will be called when a device interrupts on any of a specified set of processors.\n\nIoConnectInterruptEx\n\n\n\nFor more information, see the WdmlibIoConnectInterruptEx function.#define IoConnectInterruptEx WdmlibIoConnectInterruptEx\n\nIoCopyCurrentIrpStackLocationToNext\n\n\n\nThe IoCopyCurrentIrpStackLocationToNext routine copies the IRP stack parameters from the current I/O stack location to the stack location of the next-lower driver.\n\nIoCreateController\n\n\n\nThe IoCreateController routine allocates memory for and initializes a controller object with a controller extension of a driver-determined size.\n\nIoCreateDevice\n\n\n\nThe IoCreateDevice routine creates a device object for use by a driver.\n\nIoCreateFile\n\n\n\nThe IoCreateFile routine either causes a new file or directory to be created, or it opens an existing file, device, directory, or volume, giving the caller a handle for the file object.\n\nIoCreateNotificationEvent\n\n\n\nThe IoCreateNotificationEvent routine creates or opens a named notification event used to notify one or more threads of execution that an event has occurred.\n\nIoCreateSymbolicLink\n\n\n\nThe IoCreateSymbolicLink routine sets up a symbolic link between a device object name and a user-visible name for the device.\n\nIoCreateSynchronizationEvent\n\n\n\nThe IoCreateSynchronizationEvent routine creates or opens a named synchronization event for use in serialization of access to hardware between two otherwise unrelated drivers.\n\nIoCreateSystemThread\n\n\n\nThe IoCreateSystemThread routine creates a system thread that executes in kernel mode, and supplies a handle for the thread.\n\nIoCreateUnprotectedSymbolicLink\n\n\n\nThe IoCreateUnprotectedSymbolicLink routine sets up an unprotected symbolic link between a device object name and a corresponding Win32-visible name.\n\nIoCsqInitialize\n\n\n\nThe IoCsqInitialize routine initializes the driver's cancel-safe IRP queue dispatch table.\n\nIoCsqInitializeEx\n\n\n\nThe IoCsqInitializeEx routine initializes the dispatch table for a cancel-safe IRP queue.\n\nIoCsqInsertIrp\n\n\n\nThe IoCsqInsertIrp routine inserts an IRP in the driver's cancel-safe IRP queue.\n\nIoCsqInsertIrpEx\n\n\n\nThe IoCsqInsertIrpEx routine inserts an IRP into the driver's cancel-safe IRP queue.\n\nIoCsqRemoveIrp\n\n\n\nThe IoCsqRemoveIrp routine removes a particular IRP from the queue.\n\nIoCsqRemoveNextIrp\n\n\n\nThe IoCsqRemoveNextIrp routine removes the next matching IRP in the queue.\n\nIoDeassignArcName\n\n\n\nThe IoDeassignArcName routine removes a symbolic link between the ARC name for a device and the named device object.\n\nIoDecrementKeepAliveCount\n\n\n\nThe IoDecrementKeepAliveCount routine decrements a reference count associated with an Windows app on a specific device.\n\nIoDeleteController\n\n\n\nThe IoDeleteController routine removes a given controller object from the system, for example, when the driver that created it is being unloaded.\n\nIoDeleteDevice\n\n\n\nThe IoDeleteDevice routine removes a device object from the system, for example, when the underlying device is removed from the system.\n\nIoDeleteSymbolicLink\n\n\n\nThe IoDeleteSymbolicLink routine removes a symbolic link from the system.\n\nIoDetachDevice\n\n\n\nThe IoDetachDevice routine releases an attachment between the caller's device object and a lower driver's device object.\n\nIoDisconnectInterrupt\n\n\n\nThe IoDisconnectInterrupt routine releases a device driver's set of interrupt object(s) when the device is paused or removed, or when the driver is being unloaded.\n\nIoDisconnectInterruptEx\n\n\n\nFor more information, see the WdmlibIoDisconnectInterruptEx function.#define IoDisconnectInterruptEx WdmlibIoDisconnectInterruptEx\n\nIoEnumerateKsrPersistentMemoryEx\n\n\n\nMicrosoft reserves the IoEnumerateKsrPersistentMemoryEx function for internal use only. Don't use this function in your code.\n\nIofCallDriver\n\n\n\nCall IoCallDriver instead. Sends an IRP to the driver associated with a specified device object.\n\nIofCompleteRequest\n\n\n\nThe IoCompleteRequest routine indicates that the caller has completed all processing for a given I/O request and is returning the given IRP to the I/O manager.\n\nIoForwardIrpSynchronously\n\n\n\nThe IoForwardIrpSynchronously routine sends an IRP to a specified driver and waits for that driver to complete the IRP.\n\nIoFreeController\n\n\n\nThe IoFreeController routine releases a previously allocated controller object when the driver has completed an I/O request.\n\nIoFreeErrorLogEntry\n\n\n\nThe IoFreeErrorLogEntry routine frees an unused error log entry.\n\nIoFreeIrp\n\n\n\nThe IoFreeIrp routine releases a caller-allocated IRP from the caller's IoCompletion routine.\n\nIoFreeKsrPersistentMemory\n\n\n\nMicrosoft reserves the IoFreeKsrPersistentMemory function for internal use only. Don't use this function in your code.\n\nIoFreeMdl\n\n\n\nThe IoFreeMdl routine releases a caller-allocated memory descriptor list (MDL).\n\nIoFreeWorkItem\n\n\n\nThe IoFreeWorkItem routine frees a work item that was allocated by IoAllocateWorkItem.\n\nIoGetActivityIdIrp\n\n\n\nThe IoGetActivityIdIrp routine retrieves the current activity ID associated with an IRP.\n\nIoGetActivityIdThread\n\n\n\nThe IoGetActivityIdThread routine returns the activity ID associated with the current thread.\n\nIoGetAffinityInterrupt\n\n\n\nFor more information, see the WdmlibIoGetAffinityInterrupt function.#define IoGetAffinityInterrupt WdmlibIoGetAffinityInterrupt\n\nIoGetAttachedDeviceReference\n\n\n\nThe IoGetAttachedDeviceReference routine in ntifs.h returns a pointer to the highest level device object in a driver stack and increments the reference count.\n\nIoGetAttachedDeviceReference\n\n\n\nThe IoGetAttachedDeviceReference routine in wdm.h returns a pointer to the highest level device object in a driver stack and increments the reference count.\n\nIoGetBootDiskInformation\n\n\n\nThe IoGetBootDiskInformation routine returns information describing the boot and system disks.\n\nIoGetConfigurationInformation\n\n\n\nThe IoGetConfigurationInformation function (ntddk.h) returns a pointer to the I/O manager's global configuration information structure.\n\nIoGetConfigurationInformation\n\n\n\nThe IoGetConfigurationInformation function (ntifs.h) returns a pointer to the I/O manager's global configuration information structure.\n\nIoGetContainerInformation\n\n\n\nThe IoGetContainerInformation routine provides information about the current state of a user session.\n\nIoGetCurrentIrpStackLocation\n\n\n\nThe IoGetCurrentIrpStackLocation routine returns a pointer to the caller's I/O stack location in the specified IRP.\n\nIoGetCurrentProcess\n\n\n\nThe IoGetCurrentProcess routine returns a pointer to the current process.\n\nIoGetDeviceDirectory\n\n\n\nReturns a handle to a directory on disk specific to the specified driver object where the driver can read and write files.\n\nIoGetDeviceInterfaceAlias\n\n\n\nThe IoGetDeviceInterfaceAlias routine returns the alias device interface of the specified device interface instance, if the alias exists.\n\nIoGetDeviceInterfacePropertyData\n\n\n\nThe IoGetDeviceInterfacePropertyData routine retrieves the current value of a device interface property.\n\nIoGetDeviceInterfaces\n\n\n\nThe IoGetDeviceInterfaces routine returns a list of device interface instances of a particular device interface class (such as all devices on the system that support a HID interface).\n\nIoGetDeviceNumaNode\n\n\n\nThe IoGetDeviceNumaNode routine gets the node number of a device.\n\nIoGetDeviceObjectPointer\n\n\n\nThe IoGetDeviceObjectPointer routine returns a pointer to the top object in the named device object's stack and a pointer to the corresponding file object, if the requested access to the objects can be granted.\n\nIoGetDeviceProperty\n\n\n\nThe IoGetDeviceProperty routine retrieves information about a device such as configuration information and the name of its PDO.\n\nIoGetDevicePropertyData\n\n\n\nThe IoGetDevicePropertyData routine retrieves the current setting for a device property.\n\nIoGetDmaAdapter\n\n\n\nThe IoGetDmaAdapter routine returns a pointer to the DMA adapter structure for a physical device object.\n\nIoGetDriverDirectory\n\n\n\nReturns a handle to a directory on disk from which the driver can read and write files. The files in that directory apply to a specific driver object.\n\nIoGetDriverObjectExtension\n\n\n\nThe IoGetDriverObjectExtension routine retrieves a previously allocated per-driver context area.\n\nIoGetFileObjectGenericMapping\n\n\n\nThe IoGetFileObjectGenericMapping routine returns information about the mapping between each generic access right and the set of specific access rights for file objects.\n\nIoGetFunctionCodeFromCtlCode\n\n\n\nThe IoGetFunctionCodeFromCtlCode macro returns the value of the function code contained in an I/O control code.\n\nIoGetInitialStack\n\n\n\nThe IoGetInitialStack routine returns the base address of the current thread's stack.\n\nIoGetInitiatorProcess\n\n\n\nThe IoGetInitiatorProcess routine retrieves the process which initiated the creation of a file object if different than the process which is issuing the create.\n\nIoGetIommuInterface\n\n\n\nRetrieves a pointer to the interface that contains pointers to IOMMU routines.\n\nIoGetIommuInterfaceEx\n\n\n\nRetrieves a pointer to the extended interface that contains a set of IOMMU routines.\n\nIoGetIoPriorityHint\n\n\n\nThe IoGetIoPriorityHint routine gets the priority hint value from an IRP.\n\nIoGetNextIrpStackLocation\n\n\n\nThe IoGetNextIrpStackLocation routine gives a higher level driver access to the next-lower driver's I/O stack location in an IRP so the caller can set it up for the lower driver.\n\nIoGetPagingIoPriority\n\n\n\nThe IoGetPagingIoPriority routine indicates the priority level of a paging I/O request.\n\nIoGetRelatedDeviceObject\n\n\n\nGiven a file object, the IoGetRelatedDeviceObject routine returns a pointer to the corresponding device object.\n\nIoGetRemainingStackSize\n\n\n\nThe IoGetRemainingStackSize routine returns the current amount of available kernel-mode stack space.\n\nIoGetShadowFileInformation\n\n\n\nThis topic describes the IoGetShadowFileInformation function.\n\nIoGetStackLimits\n\n\n\nThe IoGetStackLimits routine returns the boundaries of the current thread's stack frame.\n\nIoIncrementKeepAliveCount\n\n\n\nThe IoIncrementKeepAliveCount routine increments a reference count associated with an Windows app process on a specific device.\n\nIoInitializeDpcRequest\n\n\n\nThe IoInitializeDpcRequest routine registers a driver-supplied DpcForIsr routine.\n\nIoInitializeIrp\n\n\n\nThe IoInitializeIrp routine initializes a given IRP that was allocated by the caller.\n\nIoInitializeRemoveLock\n\n\n\nThe IoInitializeRemoveLock routine initializes a remove lock for a device object.\n\nIoInitializeTimer\n\n\n\nThe IoInitializeTimer routine sets up a driver-supplied IoTimer routine associated with a given device object.\n\nIoInitializeWorkItem\n\n\n\nThe IoInitializeWorkItem routine initializes a work item that the caller has already allocated.\n\nIoInvalidateDeviceRelations\n\n\n\nThe IoInvalidateDeviceRelations routine notifies the PnP manager that the relations for a device (such as bus relations, ejection relations, removal relations, and the target device relation) have changed.\n\nIoInvalidateDeviceState\n\n\n\nThe IoInvalidateDeviceState routine notifies the PnP manager that some aspect of the PnP state of a device has changed.\n\nIoIs32bitProcess\n\n\n\nThe IoIs32bitProcess routine checks whether the originator of the current I/O request is a 32-bit user-mode application.\n\nIoIsErrorUserInduced\n\n\n\nThe IoIsErrorUserInduced routine determines whether an I/O error encountered while processing a request to a removable-media device was caused by the user.\n\nIoIsValidIrpStatus\n\n\n\nThe IoIsValidIrpStatus routine validates the specified NTSTATUS status code value.\n\nIoIsWdmVersionAvailable\n\n\n\nThe IoIsWdmVersionAvailable routine checks whether a given WDM version is supported by the operating system.\n\nIoMakeAssociatedIrp\n\n\n\nThis routine is reserved for use by file systems and file system filter drivers.\n\nIoMarkIrpPending\n\n\n\nThe IoMarkIrpPending routine marks the specified IRP, indicating that a driver's dispatch routine subsequently returned STATUS_PENDING because further processing is required by other driver routines.\n\nIOMMU_DEVICE_CREATE\n\n\n\nTakes a physical device object and creates an IOMMU_DMA_DEVICE.\n\nIOMMU_DEVICE_DELETE\n\n\n\nDeletes the provided IOMMU_DMA_DEVICE.\n\nIOMMU_DEVICE_FAULT_HANDLER\n\n\n\nReports fault from a specific device and domain.\n\nIOMMU_DEVICE_QUERY_DOMAIN_TYPES\n\n\n\nQueries for the available types of domains that a IOMMU_DMA_DEVICE is allowed to attach to, depending on environment factors, such as platform and DMA Guard Policy.\n\nIOMMU_DOMAIN_ATTACH_DEVICE\n\n\n\nAttaches a device to an existing domain.\n\nIOMMU_DOMAIN_ATTACH_DEVICE_EX\n\n\n\nAttaches an IOMMU_DMA_DEVICE to an existing DMA device domain.\n\nIOMMU_DOMAIN_CONFIGURE\n\n\n\nConfigures a domain for use.\n\nIOMMU_DOMAIN_CREATE\n\n\n\nCreates a new DMA remapping device domain (a container for a set of page tables).\n\nIOMMU_DOMAIN_CREATE_EX\n\n\n\nCreates a new DMA device domain based on the provided domain type.\n\nIOMMU_DOMAIN_DELETE\n\n\n\nDeletes an existing domain.\n\nIOMMU_DOMAIN_DETACH_DEVICE\n\n\n\nDetaches a device from an existing domain.\n\nIOMMU_DOMAIN_DETACH_DEVICE_EX\n\n\n\nDetaches a IOMMU_DMA_DEVICE from an existing domain.\n\nIOMMU_FLUSH_DOMAIN\n\n\n\nFlushes the TLB for all entries which match this domain.\n\nIOMMU_FLUSH_DOMAIN_VA_LIST\n\n\n\nFlushes the TLB for all entries that match the specified domain's ASID and one of the addresses in the provided list.\n\nIOMMU_FREE_RESERVED_LOGICAL_ADDRESS_RANGE\n\n\n\nFrees a logical address token created by IOMMU_RESERVE_LOGICAL_ADDRESS_RANGE.\n\nIOMMU_INTERFACE_STATE_CHANGE_CALLBACK\n\n\n\nThis routine is invoked whenever there has been a system state change that affects a DMA_IOMMU_INTERFACE_EX.\n\nIOMMU_MAP_IDENTITY_RANGE\n\n\n\nCreates an identity mapping for the provided MDL in the provided domain.\n\nIOMMU_MAP_IDENTITY_RANGE_EX\n\n\n\nCreates an identity mapping for a provided physical address space in the provided domain.\n\nIOMMU_MAP_LOGICAL_RANGE\n\n\n\nMaps a range of pages into the address space of a domain.\n\nIOMMU_MAP_LOGICAL_RANGE_EX\n\n\n\nMaps physical address space into the logical address space of an IOMMU_DMA_DOMAIN.\n\nIOMMU_MAP_RESERVED_LOGICAL_RANGE\n\n\n\nMaps a reserved logical range.\n\nIOMMU_QUERY_INPUT_MAPPINGS\n\n\n\nAttempts to find input mapping IDs which are valid for the given device and populate the provided buffer with those IDs.\n\nIOMMU_REGISTER_INTERFACE_STATE_CHANGE_CALLBACK\n\n\n\nAllows the caller to register a callback to be invoked whenever any state change related to a DMA_IOMMU_INTERFACE_EX occurs.\n\nIOMMU_RESERVE_LOGICAL_ADDRESS_RANGE\n\n\n\nPreallocates logical address space that can be used for future mappings.\n\nIOMMU_SET_DEVICE_FAULT_REPORTING\n\n\n\nThis routine sets the device fault reporting state to a device already attached to a domain.\n\nIOMMU_SET_DEVICE_FAULT_REPORTING_EX\n\n\n\nThis routine set the device fault reporting state on a device already attached to a domain.\n\nIOMMU_UNMAP_IDENTITY_RANGE\n\n\n\nDeletes an identity mapping for the specified MDL.\n\nIOMMU_UNMAP_IDENTITY_RANGE_EX\n\n\n\nDeletes an identity mapping created by IOMMU_MAP_IDENTITY_RANGE_EX.\n\nIOMMU_UNMAP_LOGICAL_RANGE\n\n\n\nUnmaps a linear range from a domain.\n\nIOMMU_UNMAP_RESERVED_LOGICAL_RANGE\n\n\n\nUnmaps a previously mapped reserved logical range.\n\nIOMMU_UNREGISTER_INTERFACE_STATE_CHANGE_CALLBACK\n\n\n\nAllows the caller to deregister a registered IOMMU_REGISTER_INTERFACE_STATE_CHANGE_CALLBACK.\n\nIoOpenDeviceInterfaceRegistryKey\n\n\n\nThe IoOpenDeviceInterfaceRegistryKey routine returns a handle to a registry key for storing information about a particular device interface instance.\n\nIoOpenDeviceRegistryKey\n\n\n\nThe IoOpenDeviceRegistryKey routine returns a handle to a registry state location for a particular device instance.\n\nIoOpenDriverRegistryKey\n\n\n\nReserved for the IoOpenDriverRegistryKey function.\n\nIoPropagateActivityIdToThread\n\n\n\nThe IoPropagateActivityIdToThread routine associates the activity ID from an IRP with the current thread.\n\nIoQueryFullDriverPath\n\n\n\nThe IoQueryFullDriverPath routine retrieves the full path name of the binary file that is loaded for the specified driver object.\n\nIoQueryKsrPersistentMemorySize\n\n\n\nMicrosoft reserves the IoQueryKsrPersistentMemorySize function for internal use only. Don't use this function in your code.\n\nIoQueryKsrPersistentMemorySizeEx\n\n\n\nMicrosoft reserves the IoQueryKsrPersistentMemorySizeEx function for internal use only. Don't use this function in your code.\n\nIoQueueWorkItem\n\n\n\nThe IoQueueWorkItem routine associates a WorkItem routine with a work item, and it inserts the work item into a queue for later processing by a system worker thread.\n\nIoQueueWorkItemEx\n\n\n\nThe IoQueueWorkItemEx routine associates a WorkItemEx routine with a work item, and it inserts the work item into a queue for later processing by a system worker thread.\n\nIoRaiseHardError\n\n\n\nThe IoRaiseHardError routine causes a dialog box to appears that warns the user that a device I/O error has occurred, which might indicate that a physical device is failing.\n\nIoRaiseInformationalHardError\n\n\n\nThe IoRaiseInformationalHardError routine sends a dialog box to the user, warning about a device I/O error that indicates why a user I/O request failed.\n\nIoRegisterBootDriverCallback\n\n\n\nThe IoRegisterBootDriverCallback routine registers a BOOT_DRIVER_CALLBACK_FUNCTION routine to be called during the initialization of a boot-start driver and its dependent DLLs.\n\nIoRegisterBootDriverReinitialization\n\n\n\nThe IoRegisterBootDriverReinitialization routine is called by a boot driver to register the driver's reinitialization routine with the I/O manager to be called after all devices have been enumerated and started.\n\nIoRegisterContainerNotification\n\n\n\nThe IoRegisterContainerNotification routine registers a kernel-mode driver to receive notifications about a specified class of events.\n\nIoRegisterDeviceInterface\n\n\n\nThe IoRegisterDeviceInterface routine registers a device interface class, if it has not been previously registered, and creates a new instance of the interface class, which a driver can subsequently enable for use by applications or other system components.\n\nIoRegisterDriverReinitialization\n\n\n\nThe IoRegisterDriverReinitialization routine is called by a driver during its initialization or reinitialization to register its Reinitialize routine to be called again before the driver's and, possibly the system's, initialization is complete.\n\nIoRegisterLastChanceShutdownNotification\n\n\n\nThe IoRegisterLastChanceShutdownNotification routine registers a driver to receive an IRP_MJ_SHUTDOWN IRP when the system is shut down, after all file systems have been flushed.\n\nIoRegisterPlugPlayNotification\n\n\n\nThe IoRegisterPlugPlayNotification routine registers a Plug and Play (PnP) notification callback routine to be called when a PnP event of the specified category occurs.\n\nIoRegisterShutdownNotification\n\n\n\nThe IoRegisterShutdownNotification routine registers the driver to receive an IRP_MJ_SHUTDOWN IRP when the system is shut down.\n\nIoReleaseCancelSpinLock\n\n\n\nLearn more about the IoReleaseCancelSpinLock routine.\n\nIoReleaseRemoveLock\n\n\n\nThe IoReleaseRemoveLock routine releases a remove lock acquired with a previous call to IoAcquireRemoveLock.\n\nIoReleaseRemoveLockAndWait\n\n\n\nThe IoReleaseRemoveLockAndWait routine releases a remove lock that the driver acquired in a previous call to IoAcquireRemoveLock, and waits until all acquisitions of the lock have been released.\n\nIoRemoveLinkShareAccess\n\n\n\nThe IoRemoveLinkShareAccess routine removes the access and link share-access information for a given open instance of a file object.\n\nIoRemoveShareAccess\n\n\n\nThe IoRemoveShareAccess routine removes the access and share-access information for a given open instance of a file object.\n\nIoReportDetectedDevice\n\n\n\nThe IoReportDetectedDevice routine reports a non-PnP device to the PnP manager.\n\nIoReportInterruptActive\n\n\n\nThe IoReportInterruptActive routine informs the operating system that a registered interrupt service routine (ISR) is active and ready to handle interrupt requests.\n\nIoReportInterruptInactive\n\n\n\nThe IoReportInterruptInactive routine informs the operating system that a registered interrupt service routine (ISR) is inactive and is not expecting interrupt requests.\n\nIoReportResourceForDetection\n\n\n\nThe IoReportResourceForDetection routine claims hardware resources in the configuration registry for a legacy device.\n\nIoReportRootDevice\n\n\n\nThe IoReportRootDevice routine reports a device that cannot be detected by a PnP bus driver to the PnP Manager. IoReportRootDevice allows only one device per driver to be created.\n\nIoReportTargetDeviceChange\n\n\n\nThe IoReportTargetDeviceChange routine notifies the PnP manager that a custom event has occurred on a device.\n\nIoReportTargetDeviceChangeAsynchronous\n\n\n\nThe IoReportTargetDeviceChangeAsynchronous routine notifies the PnP manager that a custom event has occurred on a device.\n\nIoRequestDeviceEject\n\n\n\nThe IoRequestDeviceEject routine notifies the PnP manager that the device eject button was pressed.\n\nIoRequestDpc\n\n\n\nThe IoRequestDpc routine queues a driver-supplied DpcForIsr routine to complete interrupt-driven I/O processing at a lower IRQL.\n\nIoReserveKsrPersistentMemory\n\n\n\nMicrosoft reserves the IoReserveKsrPersistentMemory function for internal use only. Don't use this function in your code.\n\nIoReserveKsrPersistentMemoryEx\n\n\n\nMicrosoft reserves the IoReserveKsrPersistentMemoryEx function for internal use only. Don't use this function in your code.\n\nIoReuseIrp\n\n\n\nThe IoReuseIrp routine reinitializes an IRP so that it can be reused.\n\nIosb64ToIosb\n\n\n\nThe Iosb64ToIosb function...\n\nIosbToIosb64\n\n\n\nThe IosbToIosb64 function...\n\nIoSetActivityIdIrp\n\n\n\nThe IoSetActivityIdIrp routine associates an activity ID with an IRP.\n\nIoSetActivityIdThread\n\n\n\nThe IoSetActivityIdThread routine associates an activity ID with the current thread. Drivers should use this routine when they are tracing aware and are issuing I/O on a worker thread.\n\nIoSetCancelRoutine\n\n\n\nThe IoSetCancelRoutine routine sets up a driver-supplied Cancel routine to be called if a given IRP is canceled.\n\nIoSetCompletionRoutine\n\n\n\nThe IoSetCompletionRoutine routine registers an IoCompletion routine, which will be called when the next-lower-level driver has completed the requested operation for the given IRP.\n\nIoSetCompletionRoutineEx\n\n\n\nThe IoSetCompletionRoutineEx routine registers an IoCompletion routine, which is called when the next-lower-level driver has completed the requested operation for the given IRP.\n\nIoSetDeviceInterfacePropertyData\n\n\n\nThe IoSetDeviceInterfacePropertyData routine modifies the current value of a device interface property.\n\nIoSetDeviceInterfaceState\n\n\n\nThe IoSetDeviceInterfaceState routine enables or disables an instance of a previously registered device interface class.\n\nIoSetDevicePropertyData\n\n\n\nThe IoSetDevicePropertyData routine modifies the current setting for a device property.\n\nIoSetHardErrorOrVerifyDevice\n\n\n\nLower-level drivers call the IoSetHardErrorOrVerifyDevice routine to identify a removable media device that has encountered an error, so that a file system driver can prompt the user to verify that the medium is valid.\n\nIoSetIoPriorityHint\n\n\n\nThe IoSetIoPriorityHint routine sets the priority hint value for an IRP.\n\nIoSetLinkShareAccess\n\n\n\nThe IoSetLinkShareAccess routine sets the access rights for link sharing the specified file object.\n\nIoSetMasterIrpStatus\n\n\n\nThe IoSetMasterIrpStatus routine conditionally replaces the Status value in an IRP with the specified NTSTATUS value.\n\nIoSetNextIrpStackLocation\n\n\n\nThe IoSetNextIrpStackLocation routine sets the IRP stack location in a driver-allocated IRP to that of the caller.\n\nIoSetShadowFileInformation\n\n\n\nThis topic describes the IoSetShadowFileInformation function.\n\nIoSetShareAccess\n\n\n\nThe IoSetShareAccess routine sets the access rights for sharing the given file object.\n\nIoSetShareAccessEx\n\n\n\nThe IoSetShareAccessEx routine sets the access rights for sharing the specified file object.\n\nIoSetStartIoAttributes\n\n\n\nThe IoSetStartIoAttributes routine in ntifs.h sets attributes for the driver's StartIo routine.\n\nIoSetStartIoAttributes\n\n\n\nThe IoSetStartIoAttributes routine in wdm.h sets attributes for the driver's StartIo routine.\n\nIoSetSystemPartition\n\n\n\nThe IoSetSystemPartition routine sets the boot partition for the system.\n\nIoSetThreadHardErrorMode\n\n\n\nThe IoSetThreadHardErrorMode routine enables or disables hard error reporting for the current thread.\n\nIoSizeOfIrp\n\n\n\nThe IoSizeOfIrp routine in ntifs.h determines the size in bytes for an IRP, given the number of stack locations in the IRP.\n\nIoSizeOfIrp\n\n\n\nThe IoSizeOfIrp routine in wdm.h determines the size in bytes for an IRP, given the number of stack locations in the IRP.\n\nIoSizeofWorkItem\n\n\n\nThe IoSizeofWorkItem routine returns the size, in bytes, of an IO_WORKITEM structure.\n\nIoStartNextPacket\n\n\n\nThe IoStartNextPacket routine in ntifs.h dequeues the next IRP from the given device object's associated device queue and calls the driver's StartIo routine.\n\nIoStartNextPacket\n\n\n\nThe IoStartNextPacket routine in wdm.h dequeues the next IRP from the given device object's associated device queue and calls the driver's StartIo routine.\n\nIoStartNextPacketByKey\n\n\n\nThe IoStartNextPacketByKey routine in ntifs.h dequeues the next I/O request packet from the specified device object's associated device queue.\n\nIoStartNextPacketByKey\n\n\n\nThe IoStartNextPacketByKey routine in wdm.h dequeues the next I/O request packet from the specified device object's associated device queue.\n\nIoStartPacket\n\n\n\nThe IoStartPacket routine in ntifs.h calls the driver's StartIo routine with an IRP or inserts the IRP into the device queue for the given device object.\n\nIoStartPacket\n\n\n\nThe IoStartPacket routine in wdm.h calls the driver's StartIo routine with an IRP or inserts the IRP into the device queue for the given device object.\n\nIoStartTimer\n\n\n\nThe IoStartTimer routine in ntifs.h enables the timer associated with a given device object so the driver-supplied IoTimer routine is called once per second.\n\nIoStartTimer\n\n\n\nThe IoStartTimer routine in wdm.h enables the timer associated with a given device object so the driver-supplied IoTimer routine is called once per second.\n\nIoStopTimer\n\n\n\nThe IoStopTimer routine in ntifs.h disables the timer for a specified device object so the driver-supplied IoTimer routine is not called.\n\nIoStopTimer\n\n\n\nThe IoStopTimer routine in wdm.h disables the timer for a specified device object so the driver-supplied IoTimer routine is not called.\n\nIoTransferActivityId\n\n\n\nThe IoTransferActivityId routine logs an ETW transfer event using the I/O tracing provider on behalf of the caller. This allows a driver to associate two related activity IDs without requiring a specific provider to be enabled.\n\nIoUninitializeWorkItem\n\n\n\nThe IoUninitializeWorkItem routine uninitializes a work item that was initialized by IoInitializeWorkItem.\n\nIoUnregisterBootDriverCallback\n\n\n\nThe IoUnRegisterBootDriverCallback routine unregisters a previously registered BOOT_DRIVER_CALLBACK_FUNCTION routine.\n\nIoUnregisterContainerNotification\n\n\n\nThe IoUnregisterContainerNotification routine cancels a container notification registration that was previously created by the IoRegisterContainerNotification routine.\n\nIoUnregisterPlugPlayNotification\n\n\n\nThis routine is obsolete in Windows 7 and later versions of Windows. The IoUnregisterPlugPlayNotification routine removes the registration of a driver's callback routine for a PnP event.\n\nIoUnregisterPlugPlayNotificationEx\n\n\n\nThe IoUnregisterPlugPlayNotificationEx routine cancels the registration of a driver's callback routine for notifications of Plug and Play (PnP) events.\n\nIoUnregisterShutdownNotification\n\n\n\nThe IoUnregisterShutdownNotification routine removes a registered driver from the shutdown notification queue.\n\nIoUpdateLinkShareAccess\n\n\n\nThe IoUpdateLinkShareAccess routine updates the share access for the given file object, usually when the file is being opened.\n\nIoUpdateLinkShareAccessEx\n\n\n\nThe IoUpdateLinkShareAccessEx routine updates the share access for the given file object, usually when the file is being opened.\n\nIoUpdateShareAccess\n\n\n\nThe IoUpdateShareAccess routine updates the share access for the given file object, usually when the file is being opened.\n\nIoValidateDeviceIoControlAccess\n\n\n\nFor more information, see the WdmlibIoValidateDeviceIoControlAccess function.\n\nIoVerifyPartitionTable\n\n\n\nThe IoVerifyPartitionTable routine checks the validity of the partition table for a disk.\n\nIoVolumeDeviceToDosName\n\n\n\nThe IoVolumeDeviceToDosName routine returns the MS-DOS path for a specified device object that represents a file system volume.\n\nIoWithinStackLimits\n\n\n\nThe IoWithinStackLimits routine determines whether a region of memory is within the stack limit of the current thread.\n\nIoWMIAllocateInstanceIds\n\n\n\nThe IoWMIAllocateInstanceIds routine allocates one or more instance IDs that are unique to the GUID.\n\nIoWMIDeviceObjectToInstanceName\n\n\n\nThe IoWMIDeviceObjectToInstanceName routine determines the instance name for the WMI class instance implemented by the driver that is specified by a device object.\n\nIoWMIDeviceObjectToProviderId\n\n\n\nThe IoWMIDeviceObjectToProviderId routine translates the specified device object into the corresponding WMI Provider ID.\n\nIoWMIExecuteMethod\n\n\n\nThe IoWMIExecuteMethod routine runs a WMI class method on the specified WMI data block instance.\n\nIoWMIHandleToInstanceName\n\n\n\nThe IoWMIHandleToInstanceName routine determines the instance name for the WMI class instance implemented by the driver that is specified by a file handle.\n\nIoWMIOpenBlock\n\n\n\nThe IoWMIOpenBlock routine opens the WMI data block object for the specified WMI class.\n\nIoWMIQueryAllData\n\n\n\nThe IoWMIQueryAllData routine returns all WMI data blocks that implement a given WMI class.\n\nIoWMIQueryAllDataMultiple\n\n\n\nThe IoWMIQueryAllDataMultiple routine returns all WMI data blocks that implement one of a set of WMI classes.\n\nIoWMIQuerySingleInstance\n\n\n\nThe IoWMIQuerySingleInstance routine returns the specified instance of a WMI data block.\n\nIoWMIQuerySingleInstanceMultiple\n\n\n\nThe IoWMIQuerySingleInstanceMultiple routine returns all WMI data block instances that implement the specified WMI classes with the specified instance names.\n\nIoWMIRegistrationControl\n\n\n\nThe IoWMIRegistrationControl routine registers or unregisters the caller as a WMI data provider for a specified device object.\n\nIoWMISetNotificationCallback\n\n\n\nThe IoWMISetNotificationCallback routine registers a notification callback for a WMI event.\n\nIoWMISetSingleInstance\n\n\n\nThe IoWMISetSingleInstance routine sets the values for properties within the data block instance that matches the specified WMI class and instance name.\n\nIoWMISetSingleItem\n\n\n\nThe IoWMISetSingleItem routine sets a single property in the data block instance that matches the specified WMI class and instance name.\n\nIoWMISuggestInstanceName\n\n\n\nThe IoWMISuggestInstanceName routine is used to request that WMI suggest a base name which a driver can use to build WMI instance names for the device.\n\nIoWMIWriteEvent\n\n\n\nThe IoWMIWriteEvent routine delivers a given event to the user-mode WMI components for notification.\n\nIoWriteErrorLogEntry\n\n\n\nThe IoWriteErrorLogEntry routine in ntifs.h queues a given error log packet to the system error logging thread.\n\nIoWriteErrorLogEntry\n\n\n\nThe IoWriteErrorLogEntry routine in wdm.h queues a given error log packet to the system error logging thread.\n\nIoWriteKsrPersistentMemory\n\n\n\nMicrosoft reserves the IoWriteKsrPersistentMemory function for internal use only. Don't use this function in your code.\n\nIsListEmpty\n\n\n\nThe IsListEmpty routine indicates whether a doubly linked list of LIST_ENTRY structures is empty.\n\nKBUGCHECK_CALLBACK_ROUTINE\n\n\n\nThe BugCheckCallback routine is executed whenever the system issues a bug check.\n\nKBUGCHECK_REASON_CALLBACK_ROUTINE\n\n\n\nDriver-implemented callback functions that the system executes when it issues a bug check.\n\nKDEFERRED_ROUTINE\n\n\n\nThe callback routine performs actions, after an InterruptService returns, of a threaded DPC, The CustomDpc routine finishes the servicing of an I/O operation, after an InterruptService routine returns.The CustomThreadedDpc routine performs the action of a threaded DPC. The system executes this routine when the threaded DPC runs.The CustomTimerDpc routine executes after a timer object's time interval expires.\n\nKeAcquireGuardedMutex\n\n\n\nLearn more about the KeAcquireGuardedMutex routine.\n\nKeAcquireGuardedMutexUnsafe\n\n\n\nLearn more about the KeAcquireGuardedMutexUnsafe function.\n\nKeAcquireInStackQueuedSpinLock\n\n\n\nLearn more about the KeAcquireInStackQueuedSpinLock routine.\n\nKeAcquireInStackQueuedSpinLockAtDpcLevel\n\n\n\nLearn more about the KeAcquireInStackQueuedSpinLockAtDpcLevel routine.\n\nKeAcquireInStackQueuedSpinLockForDpc\n\n\n\nLearn more about the KeAcquireInStackQueuedSpinLockForDpc routine.\n\nKeAcquireInterruptSpinLock\n\n\n\nLearn more about the KeAcquireInterruptSpinLock routine.\n\nKeAcquireSpinLock\n\n\n\nThe KeAcquireSpinLock routine acquires a spin lock so the caller can synchronize access to shared data in a multiprocessor-safe way by raising IRQL.\n\nKeAcquireSpinLockAtDpcLevel\n\n\n\nThe KeAcquireSpinLockAtDpcLevel routine acquires a spin lock when the caller is already running at IRQL >= DISPATCH_LEVEL.\n\nKeAcquireSpinLockForDpc\n\n\n\nLearn more about the KeAcquireSpinLockForDpc routine.\n\nKeAcquireSpinLockRaiseToDpc\n\n\n\nThe KeAcquireSpinLockRaiseToDpc routine is a faster version of the KeAcquireSpinLock routine.\n\nKeAddTriageDumpDataBlock\n\n\n\nAdds a triage dump data block to a triage dump data block array.\n\nKeAreAllApcsDisabled\n\n\n\nThe KeAreAllApcsDisabled routine indicates whether the calling thread is inside a guarded region or running at IRQL >= APC_LEVEL, which disables all APC delivery.\n\nKeAreApcsDisabled\n\n\n\nThe KeAreApcsDisabled function (ntddk.h) returns a value that indicates whether the calling thread is within a critical region or a guarded region.\n\nKeAreApcsDisabled\n\n\n\nThe KeAreApcsDisabled function (wdm.h) returns a value that indicates whether the calling thread is within a critical region or a guarded region.\n\nKeBugCheck\n\n\n\nThe KeBugCheck routine brings down the system in a controlled manner when the caller discovers an unrecoverable inconsistency that would corrupt the system if the caller continued to run.\n\nKeBugCheckEx\n\n\n\nThe KeBugCheckEx routine brings down the system in a controlled manner when the caller discovers an unrecoverable inconsistency that would corrupt the system if the caller continued to run.\n\nKeCancelTimer\n\n\n\nThe KeCancelTimer routine dequeues a timer object before the timer interval, if any was set, expires.\n\nKeClearEvent\n\n\n\nThe KeClearEvent routine sets an event to a not-signaled state.\n\nKeConvertAuxiliaryCounterToPerformanceCounter\n\n\n\nThe KeConvertAuxiliaryCounterToPerformanceCounter routine converts the specified auxiliary counter value into a performance counter value.\n\nKeConvertPerformanceCounterToAuxiliaryCounter\n\n\n\nThe KeConvertPerformanceCounterToAuxiliaryCounter routine converts the specified performance counter value into an auxiliary counter value.\n\nKeDelayExecutionThread\n\n\n\nThe KeDelayExecutionThread routine puts the current thread into an alertable or nonalertable wait state for a specified interval.\n\nKeDeregisterBoundCallback\n\n\n\nThe KeDeregisterBoundCallback routine deregisters a user-mode bound exception callback registered by KeRegisterBoundCallback.\n\nKeDeregisterBugCheckCallback\n\n\n\nThe KeDeregisterBugCheckCallback routine removes a callback routine that was registered by KeRegisterBugCheckCallback.\n\nKeDeregisterBugCheckReasonCallback\n\n\n\nThe KeDeregisterBugCheckReasonCallback routine removes a callback routine that was registered by KeRegisterBugCheckReasonCallback.\n\nKeDeregisterNmiCallback\n\n\n\nThe KeDeregisterNmiCallback routine deregisters a nonmaskable interrupt (NMI) callback registered by KeRegisterNmiCallback.\n\nKeDeregisterProcessorChangeCallback\n\n\n\nThe KeDeregisterProcessorChangeCallback routine unregisters a callback function that was previously registered with the operating system by calling the KeRegisterProcessorChangeCallback routine.\n\nKeEnterCriticalRegion\n\n\n\nThe KeEnterCriticalRegion function (ntddk.h) temporarily disables the execution of normal kernel APCs, but does not prevent special kernel APCs from running.\n\nKeEnterCriticalRegion\n\n\n\nThe KeEnterCriticalRegion function (wdm.h) temporarily disables the execution of normal kernel APCs, but does not prevent special kernel APCs from running.\n\nKeEnterGuardedRegion\n\n\n\nThe KeEnterGuardedRegion function (ntddk.h) enters a guarded region, which disables all kernel-mode APC delivery to the current thread.\n\nKeEnterGuardedRegion\n\n\n\nThe KeEnterGuardedRegion function (wdm.h) enters a guarded region, which disables all kernel-mode APC delivery to the current thread.\n\nKeExpandKernelStackAndCallout\n\n\n\nThe KeExpandKernelStackAndCallout routine calls a routine with a guaranteed amount of stack space.\n\nKeExpandKernelStackAndCalloutEx\n\n\n\nLearn more about: KeExpandKernelStackAndCalloutEx\n\nKeFlushIoBuffers\n\n\n\nThe KeFlushIoBuffers routine flushes the memory region described by an MDL from caches of all processors.\n\nKeFlushQueuedDpcs\n\n\n\nThe KeFlushQueuedDpcs routine returns after all queued DPCs on all processors have executed.\n\nKefReleaseSpinLockFromDpcLevel\n\n\n\nThe KeReleaseSpinLockFromDpcLevel routine releases an executive spin lock without changing the IRQL.\n\nKeGetCurrentIrql\n\n\n\nThe KeGetCurrentIrql routine returns the current IRQL.\n\nKeGetCurrentNodeNumber\n\n\n\nThe KeGetCurrentNodeNumber function (ntddk.h) returns the NUMA node number for the logical processor that the caller is running on.\n\nKeGetCurrentNodeNumber\n\n\n\nThe KeGetCurrentNodeNumber function (wdm.h) returns the NUMA node number for the logical processor that the caller is running on.\n\nKeGetCurrentProcessorNumber\n\n\n\nThe KeGetCurrentProcessorNumber routine returns the system-assigned number of the current processor on which the caller is running.\n\nKeGetCurrentProcessorNumberEx\n\n\n\nThe KeGetCurrentProcessorNumberEx function (ntddk.h) returns the processor number of the logical processor that the caller is running on.\n\nKeGetCurrentProcessorNumberEx\n\n\n\nThe KeGetCurrentProcessorNumberEx function (wdm.h) returns the processor number of the logical processor that the caller is running on.\n\nKeGetCurrentThread\n\n\n\nThe KeGetCurrentThread routine identifies the current thread.\n\nKeGetProcessorIndexFromNumber\n\n\n\nThe KeGetProcessorIndexFromNumber routine in ntifs.h converts a group number and a group-relative processor number to a systemwide processor index.\n\nKeGetProcessorIndexFromNumber\n\n\n\nThe KeGetProcessorIndexFromNumber routine in wdm.h converts a group number and a group-relative processor number to a systemwide processor index.\n\nKeGetProcessorNumberFromIndex\n\n\n\nThe KeGetProcessorNumberFromIndex routine in ntifs.h converts a systemwide processor index to a group number and a group-relative processor number.\n\nKeGetProcessorNumberFromIndex\n\n\n\nThe KeGetProcessorNumberFromIndex routine in wdm.h converts a systemwide processor index to a group number and a group-relative processor number.\n\nKeGetRecommendedSharedDataAlignment\n\n\n\nThe KeGetRecommendedSharedDataAlignment routine returns the preferred alignment for memory structures that can be accessed by more than one processor.\n\nKeInitializeCrashDumpHeader\n\n\n\nThe KeInitializeCrashDumpHeader routine supplies the header information the system requires for a crash dump file.\n\nKeInitializeCrashDumpHeader\n\n\n\nLearn how the KeInitializeCrashDumpHeader routine supplies the header information the system requires for a crash dump file.\n\nKeInitializeDeviceQueue\n\n\n\nThe KeInitializeDeviceQueue routine initializes a device queue object to a not-busy state.\n\nKeInitializeDpc\n\n\n\nThe KeInitializeDpc routine initializes a DPC object, and registers a CustomDpc routine for that object.\n\nKeInitializeEvent\n\n\n\nThe KeInitializeEvent routine initializes an event object as a synchronization (single waiter) or notification type event and sets it to a signaled or not-signaled state.\n\nKeInitializeGuardedMutex\n\n\n\nThe KeInitializeGuardedMutex routine initializes a guarded mutex.\n\nKeInitializeMutex\n\n\n\nThe KeInitializeMutex routine initializes a mutex object, setting it to a signaled state.\n\nKeInitializeSemaphore\n\n\n\nThe KeInitializeSemaphore routine initializes a semaphore object with a specified count and specifies an upper limit that the count can attain.\n\nKeInitializeSpinLock\n\n\n\nThe KeInitializeSpinLock routine initializes a variable of type KSPIN_LOCK.\n\nKeInitializeThreadedDpc\n\n\n\nThe KeInitializeThreadedDpc routine initializes a threaded DPC object, and registers a CustomThreadedDpc routine for that object.\n\nKeInitializeTimer\n\n\n\nThe KeInitializeTimer routine initializes a timer object.\n\nKeInitializeTimerEx\n\n\n\nThe KeInitializeTimerEx routine initializes an extended kernel timer object.\n\nKeInsertByKeyDeviceQueue\n\n\n\nThe KeInsertByKeyDeviceQueue routine acquires the spin lock for the specified DeviceQueue and queues an entry according to the specified sort-key value if the device queue is set to a busy state.\n\nKeInsertDeviceQueue\n\n\n\nThe KeInsertDeviceQueue routine acquires the spin lock for the specified device queue object and, if the device queue is set to a busy state, queues the specified entry.\n\nKeInsertQueueDpc\n\n\n\nThe KeInsertQueueDpc routine queues a DPC for execution.\n\nKeInvalidateAllCaches\n\n\n\nThe KeInvalidateAllCaches routine flushes all processor caches.\n\nKeInvalidateRangeAllCaches\n\n\n\nThe KeInvalidateRangeAllCaches routine flushes the specified virtual address range from all processor caches.\n\nKeIpiGenericCall\n\n\n\nThe KeIpiGenericCall routine causes the specified routine to run on all processors simultaneously.\n\nKeIsExecutingDpc\n\n\n\nChecks whether a DPC is being executed on current processor.\n\nKeLeaveCriticalRegion\n\n\n\nThe KeLeaveCriticalRegion routine reenables the delivery of normal kernel-mode APCs that were disabled by a preceding call to KeEnterCriticalRegion.\n\nKeLeaveCriticalRegion\n\n\n\nLearn how the KeLeaveCriticalRegion routine reenables the delivery of normal kernel-mode APCs that were disabled by a preceding call to KeEnterCriticalRegion.\n\nKeLeaveGuardedRegion\n\n\n\nThe KeLeaveGuardedRegion routine exits a guarded region entered by KeEnterGuardedRegion.\n\nKeLeaveGuardedRegion\n\n\n\nLearn how the KeLeaveGuardedRegion routine exits a guarded region entered by KeEnterGuardedRegion.\n\nKeLowerIrql\n\n\n\nThe KeLowerIrql routine restores the IRQL on the current processor to its original value.\n\nKeMemoryBarrier\n\n\n\nThe KeMemoryBarrier routine creates a barrier at its position in the code\u2014across which the compiler and the processor cannot move any operations.\n\nKePulseEvent\n\n\n\nThe KePulseEvent routine atomically sets an event object to a signaled state, attempts to satisfy as many waits as possible, and then resets the event object to a not-signaled state.\n\nKeQueryActiveGroupCount\n\n\n\nThe KeQueryActiveGroupCount routine returns the number of active processor groups in a multiprocessor system.\n\nKeQueryActiveGroupCount\n\n\n\nLearn how the KeQueryActiveGroupCount routine returns the number of active processor groups in a multiprocessor system.\n\nKeQueryActiveProcessorCount\n\n\n\nThe KeQueryActiveProcessorCount routine returns the number of currently active processors.\n\nKeQueryActiveProcessorCount\n\n\n\nLearn how the KeQueryActiveProcessorCount routine returns the number of currently active processors.\n\nKeQueryActiveProcessorCountEx\n\n\n\nThe KeQueryActiveProcessorCountEx routine returns the number of active logical processors in a specified group in a multiprocessor system or in the entire system.\n\nKeQueryActiveProcessorCountEx\n\n\n\nLearn how the KeQueryActiveProcessorCountEx routine returns the number of active logical processors in a specified group in a multiprocessor system or in the entire system.\n\nKeQueryActiveProcessors\n\n\n\nThe KeQueryActiveProcessors routine returns a bitmask of the currently active processors.\n\nKeQueryActiveProcessors\n\n\n\nLearn how the KeQueryActiveProcessors routine returns a bitmask of the currently active processors.\n\nKeQueryAuxiliaryCounterFrequency\n\n\n\nThe KeQueryAuxiliaryCounterFrequency routine returns frequency of the auxiliary counter in units of Hz.\n\nKeQueryDpcWatchdogInformation\n\n\n\nThe KeQueryDpcWatchdogInformation routine returns the deferred procedure call (DPC) watchdog timer values for the current processor.\n\nKeQueryGroupAffinity\n\n\n\nThe KeQueryGroupAffinity routine returns an affinity mask that identifies the active logical processors in a specified group in a multiprocessor system.\n\nKeQueryGroupAffinity\n\n\n\nLearn how the KeQueryGroupAffinity routine returns an affinity mask that identifies the active logical processors in a specified group in a multiprocessor system.\n\nKeQueryHardwareCounterConfiguration\n\n\n\nThe KeQueryHardwareCounterConfiguration routine queries the operating system for the list of hardware counters to use for thread profiling.\n\nKeQueryHighestNodeNumber\n\n\n\nThe KeQueryHighestNodeNumber routine returns the highest node number in a multiprocessor system that has a non-uniform memory access (NUMA) architecture.\n\nKeQueryHighestNodeNumber\n\n\n\nLearn how the KeQueryHighestNodeNumber routine returns the highest node number in a multiprocessor system that has a non-uniform memory access (NUMA) architecture.\n\nKeQueryInterruptTime\n\n\n\nThe KeQueryInterruptTime routine returns the current value of the system interrupt time count, with accuracy to within system clock tick.\n\nKeQueryInterruptTimePrecise\n\n\n\nThe KeQueryInterruptTimePrecise routine returns the current value of the system interrupt time count, with accuracy to within a microsecond.\n\nKeQueryLogicalProcessorRelationship\n\n\n\nThe KeQueryLogicalProcessorRelationship routine gets information about the relationships of one or more processors to the other processors in a multiprocessor system.\n\nKeQueryMaximumGroupCount\n\n\n\nThe KeQueryMaximumGroupCount routine returns the maximum number of groups in a multiprocessor system.\n\nKeQueryMaximumGroupCount\n\n\n\nLearn how the KeQueryMaximumGroupCount routine returns the maximum number of groups in a multiprocessor system.\n\nKeQueryMaximumProcessorCount\n\n\n\nThe KeQueryMaximumProcessorCount routine returns the maximum number of processors.\n\nKeQueryMaximumProcessorCount\n\n\n\nLearn how the KeQueryMaximumProcessorCount routine returns the maximum number of processors.\n\nKeQueryMaximumProcessorCountEx\n\n\n\nThe KeQueryMaximumProcessorCountEx routine returns the maximum number of logical processors in a specified group in a multiprocessor system.\n\nKeQueryMaximumProcessorCountEx\n\n\n\nLearn how the KeQueryMaximumProcessorCountEx routine returns the maximum number of logical processors in a specified group in a multiprocessor system.\n\nKeQueryNodeActiveAffinity\n\n\n\nThe KeQueryNodeActiveAffinity routine gets the current processor affinity of a specified node in a multiprocessor system that has a non-uniform memory access (NUMA) architecture.\n\nKeQueryNodeActiveAffinity2\n\n\n\nThis routine returns the current multi-group processor affinity of the given NUMA node.\n\nKeQueryNodeActiveProcessorCount\n\n\n\nThis routine returns the number of active processors in the given NUMA node across all groups.\n\nKeQueryNodeMaximumProcessorCount\n\n\n\nThe KeQueryNodeMaximumProcessorCount routine returns the maximum number of logical processors that a specified node in a non-uniform memory access (NUMA) multiprocessor system can contain.\n\nKeQueryNodeMaximumProcessorCount\n\n\n\nLearn how the KeQueryNodeMaximumProcessorCount routine returns the maximum number of logical processors that a specified node in a non-uniform memory access (NUMA) multiprocessor system can contain.\n\nKeQueryPerformanceCounter\n\n\n\nThe KeQueryPerformanceCounter routine in wdm.h retrieves the current value and frequency of the performance counter.\n\nKeQueryPriorityThread\n\n\n\nThe KeQueryPriorityThread routine returns the current priority of a particular thread.\n\nKeQueryRuntimeThread\n\n\n\nThe KeQueryRuntimeThread routine reports the accumulated kernel-mode and user-mode run time of a thread, in clock ticks.\n\nKeQuerySystemTime\n\n\n\nThe KeQuerySystemTime routine obtains the current system time.\n\nKeQuerySystemTimePrecise\n\n\n\nThe KeQuerySystemTimePrecise routine retrieves the current system time, and is more precise than the KeQuerySystemTime routine.\n\nKeQueryTickCount\n\n\n\nThe KeQueryTickCount routine maintains a count of the interval timer interrupts that have occurred since the system was booted.\n\nKeQueryTickCount\n\n\n\nLearn how the KeQueryTickCount routine maintains a count of the interval timer interrupts that have occurred since the system was booted.\n\nKeQueryTimeIncrement\n\n\n\nThe KeQueryTimeIncrement routine returns the number of 100-nanosecond units that are added to the system time each time the interval clock interrupts.\n\nKeQueryTotalCycleTimeThread\n\n\n\nThe KeQueryTotalCycleTimeThread routine returns the accumulated cycle time for the specified thread.\n\nKeQueryUnbiasedInterruptTime\n\n\n\nThe KeQueryUnbiasedInterruptTime routine returns the current value of the system interrupt time count.\n\nKeRaiseIrql\n\n\n\nThe KeRaiseIrql routine raises the hardware priority to the specified IRQL value, thereby masking off interrupts of equivalent or lower IRQL on the current processor.\n\nKeRaiseIrqlToDpcLevel\n\n\n\nThe KeRaiseIrqlToDpcLevel routine raises the hardware priority to IRQL = DISPATCH_LEVEL, thereby masking off interrupts of equivalent or lower IRQL on the current processor.\n\nKeRaiseIrqlToDpcLevel\n\n\n\nLearn how the KeRaiseIrqlToDpcLevel routine raises the hardware priority to IRQL = DISPATCH_LEVEL, thereby masking off interrupts of equivalent or lower IRQL on the current processor.\n\nKeReadStateEvent\n\n\n\nThe KeReadStateEvent routine returns the current state, signaled or not-signaled, of an event object.\n\nKeReadStateMutex\n\n\n\nThe KeReadStateMutex routine returns the current state, signaled or not-signaled, of the specified mutex object.\n\nKeReadStateSemaphore\n\n\n\nThe KeReadStateSemaphore routine returns the current state, signaled or not-signaled, of the specified semaphore object.\n\nKeReadStateTimer\n\n\n\nThe KeReadStateTimer routine reads the current state of a timer object.\n\nKeRegisterBoundCallback\n\n\n\nThe KeRegisterBoundCallback routine registers a routine to be called whenever a user-mode bound exception occurs.\n\nKeRegisterBugCheckCallback\n\n\n\nThe KeRegisterBugCheckCallback routine registers a BugCheckCallback routine, which executes when the operating system issues a bug check.\n\nKeRegisterBugCheckReasonCallback\n\n\n\nThe KeRegisterBugCheckReasonCallback routine registers a KbCallbackDumpIo, KbCallbackSecondaryDumpData, or KbCallbackAddPages routine, which executes when the operating system issues a bug check.\n\nKeRegisterNmiCallback\n\n\n\nThe KeRegisterNmiCallback routine registers a routine to be called whenever a nonmaskable interrupt (NMI) occurs.\n\nKeRegisterProcessorChangeCallback\n\n\n\nThe KeRegisterProcessorChangeCallback routine registers a callback function with the operating system so that the operating system will notify the driver when a new processor is added to the hardware partition.\n\nKeReleaseGuardedMutex\n\n\n\nThe KeReleaseGuardedMutex routine releases a guarded mutex acquired with KeAcquireGuardedMutex or KeTryToAcquireGuardedMutex.\n\nKeReleaseGuardedMutexUnsafe\n\n\n\nThe KeReleaseGuardedMutexUnsafe routine releases a guarded mutex acquired by KeAcquireGuardedMutexUnsafe.\n\nKeReleaseInStackQueuedSpinLock\n\n\n\nThe KeReleaseInStackQueuedSpinLock routine releases a queued spin lock acquired by KeAcquireInStackQueuedSpinLock.\n\nKeReleaseInStackQueuedSpinLockForDpc\n\n\n\nThe KeReleaseInStackQueuedSpinLockForDpc routine releases a queued spin lock that was acquired by calling KeAcquireInStackQueuedSpinLockForDpc.\n\nKeReleaseInStackQueuedSpinLockFromDpcLevel\n\n\n\nThe KeReleaseInStackQueuedSpinLockFromDpcLevel routine releases a queued spin lock acquired by KeAcquireInStackQueuedSpinLockAtDpcLevel.\n\nKeReleaseInterruptSpinLock\n\n\n\nThe KeReleaseInterruptSpinLock routine releases an interrupt spin lock acquired by KeAcquireInterruptSpinLock.\n\nKeReleaseMutex\n\n\n\nThe KeReleaseMutex routine releases a mutex object, and specifies whether the caller is to call one of the KeWaitXxx routines as soon as KeReleaseMutex returns control.\n\nKeReleaseSemaphore\n\n\n\nThe KeReleaseSemaphore routine releases the specified semaphore object.\n\nKeReleaseSpinLock\n\n\n\nThe KeReleaseSpinLock routine releases a spin lock and restores the original IRQL at which the caller was running.\n\nKeReleaseSpinLockForDpc\n\n\n\nThe KeReleaseSpinLockForDpc routine releases a spin lock that was acquired by calling KeAcquireSpinLockForDpc.\n\nKeReleaseSpinLockFromDpcLevel\n\n\n\nLearn how the KeReleaseSpinLockFromDpcLevel routine releases an executive spin lock without changing the IRQL.\n\nKeRemoveByKeyDeviceQueue\n\n\n\nThe KeRemoveByKeyDeviceQueue routine removes an entry, selected according to a sort key value, from the specified device queue.\n\nKeRemoveDeviceQueue\n\n\n\nThe KeRemoveDeviceQueue routine removes an entry from the head of a specified device queue.\n\nKeRemoveEntryDeviceQueue\n\n\n\nThe KeRemoveEntryDeviceQueue routine returns whether the specified entry is in the device queue and removes it, if it was queued, from the device queue.\n\nKeRemoveQueueDpc\n\n\n\nThe KeRemoveQueueDpc routine removes the specified DPC object from the system DPC queue.\n\nKeResetEvent\n\n\n\nThe KeResetEvent routine resets a specified event object to a not-signaled state and returns the previous state of that event object.\n\nKeRestoreExtendedProcessorState\n\n\n\nThe KeRestoreExtendedProcessorState routine restores extended processor state information that was previously saved.\n\nKeRestoreFloatingPointState\n\n\n\nThe KeRestoreFloatingPointState routine restores the nonvolatile floating-point context saved by the preceding call to KeSaveFloatingPointState.\n\nKeRevertToUserAffinityThreadEx\n\n\n\nThe KeRevertToUserAffinityThreadEx routine restores the previous affinity of the current thread.\n\nKeRevertToUserGroupAffinityThread\n\n\n\nThe KeRevertToUserGroupAffinityThread routine restores the group affinity of the calling thread to its original value at the time that the thread was created.\n\nKeSaveExtendedProcessorState\n\n\n\nThe KeSaveExtendedProcessorState routine saves extended processor state information.\n\nKeSaveFloatingPointState\n\n\n\nThe KeSaveFloatingPointState routine saves the nonvolatile floating-point context so the caller can carry out floating-point operations.\n\nKeSetBasePriorityThread\n\n\n\nThe KeSetBasePriorityThread routine sets the run-time priority, relative to the current process, for a given thread.\n\nKeSetCoalescableTimer\n\n\n\nThe KeSetCoalescableTimer routine sets the initial expiration time and period of a timer object and specifies how much delay can be tolerated in the expiration times.\n\nKeSetEvent\n\n\n\nThe KeSetEvent routine sets an event object to a signaled state if the event was not already signaled, and returns the previous state of the event object.\n\nKeSetHardwareCounterConfiguration\n\n\n\nThe KeSetHardwareCounterConfiguration routine specifies a list of hardware counters to use for thread profiling.\n\nKeSetImportanceDpc\n\n\n\nThe KeSetImportanceDpc routine specifies how soon the DPC routine is run.\n\nKeSetImportanceDpc\n\n\n\nLearn how the KeSetImportanceDpc routine specifies how soon the DPC routine is run.\n\nKeSetKernelStackSwapEnable\n\n\n\nThe KeSetKernelStackSwapEnable routine enables and disables swapping of the caller's stack to disk.\n\nKeSetPriorityThread\n\n\n\nThe KeSetPriorityThread routine sets the run-time priority of a driver-created thread.\n\nKeSe"}, {"url": "https://link.springer.com/chapter/10.1007/978-1-4842-6106-4_16", "page_content": "First, let\u2019s see how the kernel can prevent the exploits at runtime.\n\nCode Protection\n\nThe code protection techniques are used to prevent code injection attacks. Code protection includes three aspects \u2013 code integrity guard (CIG), data execution prevention (DEP), and arbitrary code guard (ACG). Figure 16-1 shows the memory layout with DEP/CIG/ACG in the UEFI firmware as an example.\n\nFigure 16-1 Code Protection (DEP, CIG, ACG) in UEFI Firmware Full size image\n\nCode Integrity Guard\n\nCode integrity guard means that the firmware can only load code that has been signed. If the code is not signed or the code is signed by an unknown entity, then the code will not be loaded.\n\nIn Chapters 4, 6, and 8, we have discussed different variants of a code integrity checker. Table 16-2 shows the summary of the verifier and the components to be verified. The final firmware solution may choose all of them or a partial subset of them based upon the threat model.\n\nTable 16-2 Code Integrity Guard Summary Full size table\n\nFor example, if your platform trusts the non-host firmware but not the platform OEM firmware, then you can use either Cerberus or Titan as the platform Root-of-Trust or Intel Boot Guard as the silicon Authenticated Code Module to perform the verification. But if you want to verify the non-host firmware as well, then Intel Boot Guard is not a choice because it does not have such a capability.\n\nIf platform firmware needs to load the third-party components from other storage areas, such as the disk or a PCI host bus adapter card, then UEFI secure boot can be used to verify the integrity of the PCI option ROM or the OS loader. If the system is very specific in that it does not have the PCI card and the OS loader is integrated into system firmware, then UEFI secure boot is not required. You can choose a platform Root-of-Trust to verify the OEM firmware and the OS kernel and then depend upon the OS kernel to verify the drivers from disk.\n\nLast of all, if a platform trusts all devices, then the device authentication process can be skipped. If you are designing a high-assurance platform and require verification of any hardware component, then you need a platform Root-of-Trust (PRoT) to verify the non-host firmware. These non-host firmware entities can include the baseboard management controller (BMC) and management engine (ME), also known as Server Platform Service (SPS), and so on. And these non-host firmware entities can have their device firmware accessed via the Secure Protocol and Data Model (SPDM) protocol via PCI data object exchange (DOE) or Management Component Transport Protocol (PMCI) on SMBus.\n\nThere are two typical ways for the code integrity verification to occur based upon if the image is readable:\n\n1. Load the image and verify.\n\nThe verifier can hold an image hash as the verification policy. See Figure 16-2. The disadvantage of this technique is that whenever the image is updated, the image hash needs to be updated. The alternative is to use a digital signature for the image. The image can include a public key and the signature of the image. The verifier can carry the hash of the public key and use it to verify the public key of the image for use in the identification process. Then the verifier can use the public key itself to verify the signature for the authentication process. See Figure 16-3. This method is used when the verifier has the capability to load the image. Cerberus, Intel Boot Guard, and UEFI secure boot leverage this technique.\n\nFigure 16-2 Verification for Readable Firmware Image via Hash Full size image\n\nFigure 16-3 Verification for Readable Firmware Image via Digital Signature Full size image\n\nFigure 16-4 Verification for Device Firmware Image via Challenge/Response Full size image\n\n2. Read the key and challenge/response.\n\nSometimes the verifier does not have capability to read the image. For example, the host system firmware cannot access the device firmware. As such, we can rely on a device root-of-trust to verify the device firmware image and depend upon the device root-of-trust to provide verification evidence to the host system firmware. The host verifier can ask for a device public key and then send a challenge to the device with a random number. Then the host will verify the response based upon the signature of the random number signed with the private key by the device. See Figure 16-4. This technique is different from solution #1 to verify the image directly since herein we verify the identity of the device root-of-trust. Since it is a root-of-trust, we trust that it will verify the device firmware image. This protocol is defined in the Secure Protocol and Data Model (SPDM) specification and used for the device measurement, authentication, and session creation. It is also adopted by hardware device standards such as Peripheral Component Interconnection Express (PCIe), Compute Express Link (CXL), and Universal Serial Bus (USB).\n\nData Execution Prevention\n\nData execution prevention (DEP) means that the system kernel marks the code region to be write protected (WP) and marks the data region to be non-executable (NX). This rule could be applied to any executable images, such as the portable and executable (PE) common object file format (COFF) image or the executable and linkable format (ELF) image. It should also be applied to the execution environment, such as the stack or the heap. See Figure 16-5.\n\nFigure 16-5 Firmware DEP Environment Full size image\n\nDEP is supported by the operating system directly. There are some firmware special enabling areas we need to take care of:\n\n1) Most firmware has strict size requirements. As such, the link script might combine the code region to the data region and use minimal alignment settings, such as 32 bytes. The DEP technique cannot be applied to this configuration. The minimal requirement for DEP is to separate the code region from the data region and to use a minimal page size as alignment, such as 4K bytes. 2) Some firmware images may include self-modification code, especially mode switch code, because the segment location can only be determined at runtime. This is generally not recommended. The stack or global data region can be used to hold such information. 3) The execute in place (XIP) image on the flash region may be used in the early firmware boot phase before the permanent DRAM is initialized. The system may only have limited space for the page table. If we still need to apply the rule, we need to combine the multiple images into one big image. As such, we reduce the required entry numbers in the page table for the executable region.\n\nArbitrary Code Guard\n\nThe arbitrary code guard means that the system kernel marks all memory regions to be non-executable, including the stack, the heap, and any unused pages. The system kernel is the only entity that can allocate executable memory when it dispatches the images. Other modules cannot allocate the executable memory themselves.\n\nThe ACG technique is an extension of DEP. It blocks code injection because other modules cannot allocate code pages and all existing code pages are marked as read-only.\n\nIn practice, we do see some usages wherein a driver may allocate executable code. For example, a 64-bit mode UEFI code module may need to switch into 32-bit mode in order to call 32-bit Firmware Support Package (FSP) APIs. If this module detects itself to be located in above\u20134 GB memory, it will allocate an executable code region in memory below 4 GB in order to perform the mode switch. As such, a kernel can choose to lock down the code region allocation after it dispatches all modules to prevent arbitrary code executing.\n\nA standalone firmware implementation can apply this rule easily because no additional images need to be loaded and no executable memory is required after all images are dispatched. However, things get complicated when the firmware needs to load the components from another domain, such as the operating system. Taking UEFI firmware as an example, after the UEFI kernel loads the OS loader, the OS loader can allocate the memory with the LoaderCode memory type for the OS kernel and jump to the OS kernel. The OS loader must have the capability to allocate executable memory for the OS kernel. The kernel needs to have knowledge of the new loaded modules and verify the code integrity before granting execution capability. Otherwise, the arbitrary code should not be executed.\n\nAddress Space Layout Randomization\n\nAddress space layout randomization (ASLR) is a technology to randomize the memory for the execution environment, such as the base address of an executable image or shared library, the program stack, and the program heap. ASLR makes it more difficult for an attacker to predict target addresses even if there is vulnerability in the program. The randomization technology can include shuffling, most likely for the image, or shifting, most likely for the data. Figure 16-6 shows the memory layout with image shuffling and data shifting in UEFI firmware as an example.\n\nFigure 16-6 ASLR in UEFI Firmware Full size image\n\nData Shifting\n\nData shifting is for heap or stack randomization. The firmware kernel can reserve a large chunk of memory for the heap. When the kernel gets the request to allocate memory, the kernel allocate more memory and shifts the return address with a random number. The random number is measured as entropy. See Figure 16-7.\n\nFigure 16-7 ASLR in UEFI Firmware Full size image\n\nLet\u2019s see an example. We have page-level allocations, and the alignment is 4K. If we set the entropy to be 3 bits, then the maximum random number is 8. The random number has eight possibilities: 0, 1, 2, 3, 4, 5, 6, and 7. As such, the final address has eight possibilities: base address + 0, + 0x1000, + 0x2000, + 0x3000, + 0x4000, + 0x5000, + 0x6000, and + 0x7000. If the attacker wants to guess the address, they only have a one-eighth probability to get the right one.\n\nIn the OS, the entropy can be quite large because the OS uses virtual memory management and multiple processes. The firmware may only have limited resources for simple memory management and a single process. As such, we might consider a different randomization strategy for firmware.\n\n1) Random shift once.\n\nThe kernel can allocate an unused memory region with a random size at the top and always allocate the exact size. See Figure 16-8. It assumes the memory allocation algorithm is top-down. If the memory allocation algorithm is bottom-up, then the unusable memory is at the bottom. This is the simplest strategy. The risk is that if the attacker knows the delta, they can calculate the rest.\n\nFigure 16-8 ASLR \u2013 Random Shift Once Full size image\n\n2) Set the randomized bar.\n\nThe kernel can shift with a random size and set a bar for the free memory search. Then the kernel allocates the exact size. See Figure 16-9. With this approach, the entropy must be a big number because a small number may cause the bar setting to be very close and to not bring too much randomness. However, there might be a case that the system has enough memory, but the bar is set too low to let the kernel find any freed memory there.\n\nFigure 16-9 ASLR \u2013 Set the Randomized Bar Full size image\n\n3) Enlarge to a fixed allocation size.\n\nThe kernel can enlarge the allocation size based upon the entropy bit \u2013 the maximum random number. Then the kernel shifts a random size and returns the final data. See Figure 16-10. The good part of this approach is that the memory allocation is deterministic. The risk of this approach is that if the entropy is too large, then it may cause an out of resource condition for the larger memory allocations.\n\nFigure 16-10 ASLR \u2013 Enlarge to a Fixed Allocation Size Full size image\n\n4) Enlarge to a randomized allocation size.\n\nA better solution for #3 is to let the kernel enlarge the allocation size based upon a random number. Then the kernel returns the final data and frees the rest of the allocated memory. See Figure 16-11.\n\nFigure 16-11 ASLR \u2013 Enlarge to a Randomized Allocation Size Full size image\n\nDifferent firmware components may use different strategies. Take UEFI firmware as an example. The reserved memory, ACPI memory, and runtime memory cannot be randomized because we must maintain the same memory layout for the S4 resume process. As such, we need to pre-allocate a big bin for these usages at the top. In the pre-EFI Initialization (PEI) phase, the memory is quite limited, and the PEI core does not support the memory-free operation. As such, we may use #1 \u2013 random shift once. In the UEFI environment, the whole of system memory is available. Then we can use #4 \u2013 enlarge to a randomized allocation size. While the system management mode exists until OS runtime, we had better use a deterministic technique, such as #3. See Figures 16-12 and 16-13.\n\nFigure 16-12 ASLR \u2013 PEI and UEFI Memory Full size image\n\nFigure 16-13 ASLR \u2013 SMM Memory Full size image\n\nThe biggest challenge of ALSR is the entropy selection. A small entropy number may result in a weakness in the protection. A small entropy number may also cause the address to be predictable within several system reboots. Taking the preceding example, the attacker can reboot the system eight times, and then they may get the right address once and attack the system successfully. However, a big entropy number may impact the stability of the system. The firmware usually runs in a resource-constrained environment. For example, X86 system management mode (SMM) only has 4~8 MB memory. A microcontroller may only have several kilobytes. A very aggressive randomization may waste the system memory too much and cause an out of resource condition in some special cases. It is also hard to debug these situations because of the randomness.\n\nData Shuffling\n\nIn order to achieve the randomization with limited resources, we can use data shuffling without shifting. This is a better solution because data shuffling can guarantee the memory reserved for the usage and eliminate the random out of resource problem. Figure 16-14 shows an example of a system employing image shuffling.\n\nFigure 16-14 ASLR \u2013 Image Shuffling Full size image\n\nThe kernel may calculate the required space for all images and allocate a big chunk at one time. Then the kernel uses a random order to load the images one by one. Besides the image location being random, the kernel may choose a random order to execute the images. The benefit of this approach is that the data allocated by the image can also be shuffled automatically.\n\nControl Flow Guard\n\nControl flow guard can be enabled by compiler defensive technology, which has been discussed in Chapter 15. Here we discuss some control flow defenses that need to be set up by the kernel.\n\nBackward-Edge Control Flow\n\nThe compiler may insert a checker in the target function for the stack cookie or ARM Pointer Authentication Code (PAC) to support backward control flow guard. Intel Control Flow Enforcement Technology (CET) uses another approach. With CET, the kernel can set up a shadow stack to catch the stack overflow. There is no need to have the compiler inject any checker in the target function. We have discussed the shadow stack concept in Chapter 15, section \u201cIntel Control Flow Enforcement Technology.\u201d\n\nBecause the kernel needs to set up the stack, the kernel may set up a shadow stack at the same time. At runtime, the shadow stack holds the function return address. This function return address in the shadow stack will be popped to compare with the function return address in the normal stack to see if the return address is modified by the malicious code. See Figure 16-15.\n\nFigure 16-15 Intel CET \u2013 Shadow Stack Full size image\n\nA firmware implementation may implement a C standard library function \u2013 setjump() and longjump() . If so, the implementation must be updated to support the shadow stack. Besides saving the normal volatile registers (RBX, RSP, RBP, RDI, RSI, R12, R13, R14, R15, XMM6~XMM15, MXCSR) in the jump buffer context, the setjump() implementation must add the shadow stack pointer (SSP) into the jump buffer. As such, the longjump() can restore the original SSP to match the original stack pointer (RSP).\n\nBecause CET relies upon the page table, if a firmware implementation needs to disable paging, such as a mode switch from X64 long mode to IA32 protected mode, the CET feature must be disabled before the paging is disabled. And CET can be reenabled after the paging is reenabled.\n\nWhen the firmware implements the CET shadow stack, it must ensure the shadow stack is implemented securely with adherence to the following listed guidelines:\n\n1) The shadow stack must be in a read-only page, with the dirty (D) bit set in the page table entry. As such, the CPU knows this is a valid shadow stack memory location and writes the content into the shadow stack. At the same time, the kernel must clear the dirty (D) bit for the normal read-only page to prevent the CPU writing any data to the normal read-only page by mistake. 2) The shadow stack contains both the segment value and return address. The valid segment value in X86 is 16 bits. As such, the kernel needs to ensure that the first 64K-byte memory is non-executable to prevent the CPU from popping the segment value as the return address and executing the code there. 3) Although CET supports the shadow stack write instruction, it is highly recommended to disable this write-shadow-stack (WRSS) feature.\n\nForward-Edge Control Flow\n\nThe compiler also supports the ability to insert a checker for the forward-edge control flow, such as the Clang Control Flow Integrity (CFI) and Microsoft Visual Studio Control Flow Guard (CFG). The compiler also supports the hardware-based control flow, such as Intel CET Indirect Branch Tracking (IBT) and ARM Branch Target Identification (BTI).\n\nWe have discussed those features in Chapter 15, sections \u201cIntel Control Flow Enforcement Technology\u201d and \u201cARM Pointer Authentication and Memory Access Control.\u201d\n\nBesides the compiler inserting the ENDBRANCH or BTI instruction at the target function, the kernel implementation needs to explicitly add the ENDBRANCH or BTI instruction to the assembly code which might be used for an indirect branch. See Figure 16-16. One example is the exception handler, and the other example is the mode switch code. Both of them are implemented in assembly code usually.\n\nFigure 16-16 Intel CET \u2013 Indirect Branch Tracking Full size image\n\nAddress Sanitizer\n\nThe address sanitizer is supported in the Clang compiler to detect buffer overflows. But the compiler needs to insert a checker to each function, which will increase the firmware code size. This might be a problem in firmware, because the firmware may load third-party binary modules. Similarly, the kernel can support the address sanitizer at some level which is independent of the compiler feature. The advantage of this approach is that only the kernel needs to be updated and other drivers can work as is.\n\nPage Table\u2013Based Heap Guard\n\nThe basic idea to detect the buffer overflow in a heap is to add a tag before and after the target buffer. Most memory management libraries already have such a tag, but the tag is only checked when the buffer is freed. We hope to do more to detect the buffer overflow at runtime, instead of just at the time of freeing the buffer. The compiler sanitizer inserts the checker for the tag when the buffer is accessed. This cannot be applied for the kernel because the kernel cannot modify the module code. What the kernel can do, though, is to leverage the hardware capability to mark the tag region to be not accessible. The page table is one option. The tag can be a not-present page. It is also called a guard page. See Figure 16-17.\n\nPage table\u2013based heap guard is to add a not-present page before and after an allocated buffer. Whenever the kernel memory management module gets the buffer allocation request, it allocates more memory for the guard pages, updates the page table to mark the two guard pages to be not present, and returns the allocated buffer in the middle. If the buffer overflow happens and the guard page is accessed, the CPU will generate a page fault exception because the guard page is marked as not-present memory.\n\nIn practice, the buffer allocation can be page-level allocation or pool-level allocation. For the page-level allocation, the guard page can be just before and after the allocated pages. See Figure 16-18. One special feature for the page-level allocation is that the allocated page can be partially freed. Figure 16-19 shows an example. There are three pages allocated at the beginning. Then the caller frees the second page in the middle and leaves a hole. In order to support the heap guard capability, the kernel memory management module needs to put the guard page in the middle to ensure the first and third pages are still guarded.\n\nFigure 16-18 Guard Page for Page-Level Allocation Full size image\n\nFigure 16-19 Guard Page for Page-Level Allocation with Partial Free Full size image\n\nFor the pool-level allocation, the guard page design is a little different. One problem with the pool-level allocation is that the allocated buffer size might not be a multiple of the page size. As such, the guard page could not catch the buffer overflow and underflow at the same time. The kernel memory management module may choose to add a guard page after the buffer to catch overflow or add a guard page before the buffer to catch underflow. See Figure 16-20. In most cases, we have seen the issues are caused by buffer overflow. As such, the guard page after the buffer can catch more issues.\n\nFigure 16-20 Guard Page for Pool-Level Allocation Full size image\n\nThe heap guard solution is a simple way to catch the buffer overflows. The page table is a mature technology and available in almost all processors. However, there are some limitations:\n\n1) The biggest problem is the size overhead. When the heap page guard is enabled, any page allocation causes two more pages to be allocated. When the heap pool guard is enabled, each pool allocation becomes a page allocation. Even a 1-byte allocation needs three pages of memory. For a resource-constrained environment, it may cause a memory out of resource condition. 2) We also observed the performance downgrade when the page table\u2013based heap guard is enabled. For each allocation and free, the kernel must reload the page table and flush the page table catch \u2013 Translation Lookaside Buffer (TLB) . In a multiprocessor environment, the kernel must synchronize the page tables and flush the TLB for all processors to make sure the buffer overflow can be caught in all CPU environments. 3) Some firmware solutions use a ROMed page table, such as the early initial phase of an X86 firmware. The page table itself is on the flash memory mapped I/O space, and it is not writable. We also observed that there are firmware solutions to lock down the page table at some level, such as the Intel BIOS runtime resiliency feature. As such, we cannot use the heap guard feature.\n\nMemory Tagging\n\nCompared to page-level protection, the memory tagging technique can be a lightweight choice. We have discussed ARM Memory Tagging Extension (MTE) in Chapter 15. See Figure 16-21.\n\nWhen the kernel gets the memory allocation request, the kernel assigns a new tag for the allocated buffer and returns to the requester. The memory before or after the allocated buffer is assigned with other tags. As such, if the out of bound access occurs, it can be detected because the tag is different. After the buffer is freed, the same buffer can be assigned with another tag. As such, the use-after-free can also be detected.\n\nThe tag is actually the high bits in the memory address. From the processor perspective, the address space is expanded. Figure 16-22 shows an example that a system has 2 bits for the tag and four tags totally.\n\nFigure 16-22 Shadow Memory Space with Tagging Full size image\n\nFigure 16-23 shows a buffer allocation case. For example, a requester invokes a service to allocate 0x60 bytes of memory. The kernel finds a free memory chunk at the address 0x8765_0080 ~ 0x8765_0100. The memory after this buffer (0x8765_0100 ~ 0x8765_0200) is marked as tag 2; then the final address after the buffer is 0x0200_0000_8765_0100 ~ 0x0200_0000_8765_0200. The memory before this buffer (0x8765_00040 ~ 0x8765_0080) is marked as tag 3; then the final address before the buffer is 0x0300_0000_8765_0080 ~ 0x0300_0000_8765_0040. The kernel chooses tag 1 for this buffer and returns 0x0100_0000_8765_0100 ~ 0x0100_0000_8765_0080. If the program has an overflow access to the memory after the buffer, then the pointer will be between 0x0100_0000_8765_0100 and 0x0100_0000_8765_0200. Because the tag of this address range is different from the valid one 0x0300_0000_8765_0100 ~ 0x0300_0000_8765_0200, the access is blocked by the CPU, and an exception is generated.\n\nFigure 16-23 Buffer Overflow Detection with Memory Tagging Full size image\n\nAfter the memory is used, the kernel needs to free the memory. The kernel changes the memory to tag 0. The valid address is switched to 0x0000_0000_8765_0100 ~ 0x0000_0000_8765_0080. Then if the program has a use-after-free issue and still accesses this region with address between 0x0100_0000_8765_0100 and 0x0100_0000_8765_0080, then the tag mismatch can be caught again.\n\nOne special advantage of memory tagging is that it can support cross-object detection if the two objects are using different tags. Similar to page table\u2013based heap guard, the memory tagging also has some limitations:\n\n1) The tagged memory size has the processor-specific alignment requirement. For example, the ARM MTE requests 16-byte aligned tagged memory. A small-sized overflow or underflow might not be detected. 2) The memory tag numbers are limited. Take ARM MTE as the example. The tag field only has 4 bits. That means there are 16 different tags available totally. The memory allocation algorithm needs to guarantee that two adjacent memory regions have different tags. In some rare cases, if the overflow happens in two address regions with the same tag, then the overflow cannot be detected.\n\nTable 16-3 shows the summary of the address sanitizer solutions.\n\nTable 16-3 Summary of Address Sanitizer Solutions Full size table\n\nStack Guard\n\nThe firmware kernel usually sets up the stack and heap for other drivers and applications. For the resource-constrained environment, we need to calculate the required stack size and required heap size precisely. One potential risk is stack overrun. If the allocated stack is too small, the stack may overlap with the heap memory which causes heap corruption. See the left-hand side of Figure 16-24.\n\nFigure 16-24 Stack Without Guard and with Guard Full size image\n\nIn order to detect a stack overrun, we can allocate a guard page \u2013 a not-present page in the page table \u2013 at the bottom of the stack. As such, when the stack overrun occurs, the CPU generates the page fault exception because of a not-present page access. Besides the guard page, we also need to allocate a known good page as the stack for the exception handler because we don\u2019t have any space in the normal stack. The stack switch is processor specific. For example, an IA32 processor needs to set up a task and use task switching for the exception. An X64 processor can use the stack switch directly as indicated in the exception handler. If we enable the shadow stack feature, then we can use the same mechanism for shadow stack as well. This is for the potential case wherein the shadow stack overrun occurs at the same time as for the normal stack. The final memory layout of the stack guard capability is shown in the right-hand side of Figure 16-24."}, {"url": "https://blog.csdn.net/qq_41608408/article/details/103965995", "page_content": "\u62b5\u6263\u8bf4\u660e\uff1a\n\n1.\u4f59\u989d\u662f\u94b1\u5305\u5145\u503c\u7684\u865a\u62df\u8d27\u5e01\uff0c\u6309\u71671:1\u7684\u6bd4\u4f8b\u8fdb\u884c\u652f\u4ed8\u91d1\u989d\u7684\u62b5\u6263\u3002\n\n2.\u4f59\u989d\u65e0\u6cd5\u76f4\u63a5\u8d2d\u4e70\u4e0b\u8f7d\uff0c\u53ef\u4ee5\u8d2d\u4e70VIP\u3001C\u5e01\u5957\u9910\u3001\u4ed8\u8d39\u4e13\u680f\u53ca\u8bfe\u7a0b\u3002"}, {"url": "https://www.encyclopedia.com/science/encyclopedias-almanacs-transcripts-and-maps/development-computer-operating-systems", "page_content": "The Development of Computer Operating Systems\n\nOverview\n\nFor most people, understanding their computers extends no further than needing to know how to be able to install programs. However, there are a number of essential elements that allow a user to make use of the computer hardware. This essay will explore the history of one of these elements\u2014the operating system. An operating system is a program that serves as an interface between the user of a computer and the hardware. It sets up an environment in which a user can run programs conveniently and efficiently. Examples of operating systems include DOS, UNIX, and Windows. There are four main components of a computer system: the hardware, the operating system, programs, and users. The operating system manages the hardware and software resources of the computer to best meet the diverse and sometimes conflicting needs of programs and users.\n\nBackground\n\nThe earliest computers did not have operating systems. Programmers interacted directly with the hardware through switches, tape, or punched cards. Because the computer could operate much more quickly than the programmer could load or unload tape or cards, the computer spent a great deal of time idle. To overcome this expensive idle time, the first rudimentary operating systems (OS) were devised. They were simple programs that were always in the memory of the computer and that ordered user programs by type and then automatically ran them one right after the other. The next step came about with the introduction of disk systems. Because disks are random access devices, the information on them can be accessed in any order. Disks were used to hold user input and output until the central processing unit was ready to use it. As soon as the CPU finished one task it could jump on the disk to another job that was ready to run. Time-sharing was the next logical progression. In time-shared operating systems the CPU handles many jobs at the same time by switching in between them so quickly that it is unnoticeable. Thus, while one user is typing in a command, the CPU is executing another user's program.\n\nMULTICS and UNIX\n\nOne of the earliest formal operating systems was MULTICS, designed between 1965 and 1972 at the Massachusetts Institute of Technology. MULTICS was a time-shared system running continuously on a large complex mainframe computer with a vast file system of shared programs and data. In 1969 Ken Thompson (1943- ) and Dennis Ritchie of the Research Group at Bell Laboratories began to work on UNIX, an operating system for minicomputers. Ritchie had previously worked on the MULTICS project, and UNIX was strongly influenced by MULTICS. (The name UNIX is a pun on MULTICS.) For this new OS, Ritchie and Brian Kernhagan developed the systems-programming language C to replace the assembly language previously used. By 1978 UNIX had become a product sold by AT&T (the parent organization of Bell Labs.) The size, simplicity, and clean design of the UNIX system encouraged programmers at sites other than Bell Labs to experiment with UNIX development. The most influential of these was a group at the University of California at Berkeley. The advances made by this group convinced the defense department to fund further research, leading to the development of 4BSD (Berkeley Software Distributions) UNIX. 4BSD proved to be fundamental to the development of the Internet. UNIX is a simple, highly flexible system designed to let the user build a more complex system if desired. It can run on mainframes, workstations, minicomputers, supercomputers, and even personal computers. Research and development of UNIX continued throughout the 1980s and 1990s, with special focus being placed on standardizing UNIX applications.\n\nApple and Microsoft\n\nWhile UNIX was spreading beyond Bell Labs, the development of the Intel 4004 microprocessor in 1971 allowed the concept of a personal computer to emerge. The Intel 4004 was an entire CPU on a single microchip. Intel and other companies continued to refine the microchip, and personal computer (PC) kits that users assembled themselves became popular among computer hobbyists. Unlike mainframe computers, personal computers were not intended to have more than one user at a time and therefore were not concerned at first with time-sharing or multitasking. Instead, as the PC market grew, emphasis was placed on convenience and ease of use for the user. In 1976 Steve Jobs (1955- ) and Steve Wozniak (1950- ) designed and built the Apple I, which consisted of little more than a circuit board. However, by 1977 they had incorporated Apple Computer and announced the Apple II, which established a benchmark for personal computers. The Apple II had a simple operating system that came on a disk and accepted basic commands from a command line. In the same year Bill Gates (1955- ) and Paul Allen (1953- ) founded Microsoft Corporation.\n\nIn 1980 a computer programmer named Tim Paterson developed an operating system called 86-DOS (Disk Operating System.) Like the Apple II and the other personal computer operating systems of the time, it was a command-line interface between the user and the PC hardware. Also in 1980 IBM decided to make a personal computer and chose Microsoft Corporation to provide the operating system for the new PC. Paterson joined Microsoft in April 1981, and by July Microsoft had bought all the rights to DOS. In August IBM sold its first PC, complete with MS-DOS 1.0. In less than a year reverse engineering had allowed competitors to produce clones of the IBM personal computer. Microsoft sold MS-DOS 1.25 to these clone makers. Throughout the 1980s MS-DOS continued to develop and advance, gaining more capabilities and meeting the needs of more powerful hardware and more advanced programs.\n\nDuring the Super Bowl in January 1984, Apple introduced America to a completely innovative computer in an Orwellian-themed advertisement. The Macintosh was the first commercially successful computer with a graphical user interface (GUI). The GUI style of operating system allowed users to interact with the computer through click buttons, pull-down menus, and other image options on the screen rather than through a command line. In addition to the graphical interface, the Macintosh had more advanced hardware than IBM-style PCs. Apple continued to offer both the Apple II and the Macintosh throughout the 1980s. By the end of the decade, the Macintosh offered multifinder properties that allowed it to do more than one task at once. The Macintosh proved extremely popular, especially within educational facilities. Despite the Macintosh's popularity, Apple lost ground in the PC market throughout the 1990s until its introduction of the Powermac G3 in 1997. This was followed in 1998 by the highly successful iMac computers, aimed at a low-end market.\n\nIn order to compete with the Macintosh, Microsoft produced Windows 1.0 in 1985, which brought the GUI interface and Macintosh-style features to DOS-compatible computers. In developing Windows, Microsoft signed an agreement with Apple that Windows 1.0 would not use Macintosh technology. When future versions of Windows did utilize Macintosh ideas, Apple took Microsoft to court for copying the \"look and feel\" of the Macintosh. Microsoft argued that the agreement only applied to Windows 1.0, and the court ruled in favor of Microsoft. In the meantime, between 1985 and 1987 Microsoft and IBM collaborated on creating a new operating system. Microsoft pulled out of the collaboration and released Windows 3.0 based on technology that had been developed jointly. IBM continued working on the new operating system and released OS/2 in 1987. Although it was a technologically advanced system, it was not a great commercial success. In 1993 Microsoft produced Windows NT, an entirely new operating system written from the ground up, designed to compete with the server market that was dominated by UNIX. The GUI on this new operating system had much the same look as Windows but with different programming underneath. Meanwhile, Windows continued to develop, with the next major advance coming with the release of Windows 95 in 1995. It included a major overhaul of the GUI, some changes to the underlying DOS, and was tested by over 50,000 individuals and companies before being released.\n\nMicrosoft was quickly taking over the PC market, and some of its practices were drawing criticism. In 1997 Microsoft was ordered to make Windows 95 available without the applications software Internet Explorer. The argument was that by automatically including Internet Explorer on Windows 95, Microsoft was using its monopoly of the PC operating system market to destroy competition in other markets, such as internet software. Microsoft appealed the order. An appeal court ruled that the 1995 injunction did not apply to Windows 98, released in 1998. However, in May of that same year the U.S. Justice Department and 20 states filed an antitrust suit against Microsoft, charging it with abusing its market powers to destroy competitors. In November 1999 Judge Thomas Jackson issued his Findings of Fact, stating that Microsoft is an illegal monopoly and that it had abused its market power in anti-competitive practices.\n\nThe Emergence of Linux\n\nWhile Apple and Microsoft were battling for space in the PC market, Linus Torvalds (1970- ) at the University of Helsinki in Finland was developing a freely distributed version of UNIX for personal computers called Linux. Linux began as a hobby for Torvalds, inspired by Minix, a small UNIX system developed by Andy Tanenbaum. In October 1991 Torvalds announced the first official version of Linux, 0.02. The system was still very rudimentary, but Torvalds put it out on the Internet for UNIX programmers and wizards to aid in its development. Hackers, programmers, and users of every flavor contributed, and by 1994 it had become a viable operating system, capable of running almost all UNIX programs. By 1996 Linux was a complete UNIX clone, capable of running X-windows\u2014the UNIX version of a GUI. Because Linux was developed completely from scratch, it contains no code from AT&T or any other proprietary source. Much of the software available for Linux is from the GNU project at the Free Software Foundation in Cambridge, MA. In 1999 it was still possible to obtain Linux and a sizeable number of programs completely free of charge. Because of its flexibility, its price, and the fact that it is adaptable to most PC hardware, Linux became quite popular in the late 1990s as an Internet server. The growing interest in Linux convinced commercial software manufacturers to make their packages compatible with the Linux system. As this trend continues Linux will become even more viable and popular.\n\nImpact\n\nThe pace of change in the computer industry makes it impossible to predict future developments in operating systems. However, this article has attempted to show that the evolution of operating systems in the second half of the twentieth century depended on a number of factors, including programmer interest, market pressures, hardware advances, and government oversight. Operating systems will continue to develop to meet the growing and changing needs of users and new hardware. It can only be hoped that the competition that gave rise to the PC revolution, the innovation that brought about GUI systems, and the free exchange of ideas that gave rise to Linux will all continue into the twenty-first century.\n\nDANIEL BONGERT AND REBECCA B. KINRAIDE\n\nFurther Reading\n\nCarlton, Jim. Apple: The Inside Story of Intrigue, Egomania, and Business Blunders. New York: Times Books, 1997.\n\nEdstrom, Jennifer and Marlin Eller. Barbarians Led by BillGates: Microsoft from the Inside. New York: Henry Holt, 1998.\n\nMalone, Michael S. Infinite Loop: How the World's Most Insanely Great Computer Company Went Insane. New York: Doubleday, 1999.\n\nRaymond, Eric S. The Cathedral and the Bazaar: Musings on Linux and Open Source by an Accidental Revolutionary. O'Reilly and Associates, 1999.\n\nWallace, James and Jim Erickson. Hard Drive: Bill Gates and the Making of the Microsoft Empire. New York: John Wiley & Sons, 1992.\n\nWallace, James. Overdrive: Bill Gates and the Race to Control Cyberspace. New York: John Wiley & Sons, 1998.\n\nYoung, Robert and Wendy Goldman Rohm. Under theRadar: How Red Hat Changed the Software Business and Took Microsoft by Surprise. Coriolis Group, 1999."}, {"url": "https://www.javatpoint.com/kernel-vs-operating-system", "page_content": "next \u2192 \u2190 prev Kernel Vs. Operating System What is Kernel? A kernel is the core of the operating system. A kernel is the first program of the operating system, which is loaded into the primary memory to begin the system's operation. It is kept inside the main memory until the system is switched off. Kernel essentially converts the commands entered by the user into a language that the machine can understand. The kernel serves as a bridge between the system's application software and its hardware. Kernel interacts directly with the hardware to inform it of the request made by the application software. An operating system cannot function without the kernel, which is a critical program for the system's working. A Kernel is responsible for process management, disk management, task management, and memory management. The kernel examines the memory space to ensure that the application program is executed correctly. It generates and destroys memory, which aids in software execution. The kernel comes into two varieties Monolithic Kernel and Microkernel. In a Monolithic Kernel, all the operating system's service runs on the kernel's main thread, which is located in the same memory region as the kernel. Monolithic kernel offers extensive access to the system's hardware. The monolithic kernel offers extensive access to the system's hardware. The Microkernel is a hardware abstraction that implements operating system services with the help of the primitives or system calls. Functions of Kernel There are various functions of the kernel: Access computer resource Memory management Device management Resource management Access Computer Resource A kernel is able to access several computer resources like I/O devices, CPU, and other resources. It serves as a bridge between the user and the system's resources. Memory Management Any method requires a certain amount of memory. As a result, memory should be allocated or deallocated for its execution. With the help of the kernel, all this memory management is done. Device Management The process makes use of the peripheral devices that are connected to the system. As a result, the allocation of these devices is handled by the kernel. Resource Management The kernel's responsibility is to share resources among different processes in such a manner that each process has uniform access to the resources. What is an Operating System? An operating system (OS) is system software that can manage the resources of a computer system. OS serves as an interface between the user and the system hardware. The operating system's interface allows the user to see the result of the command which the user enters. Without OS, it is not possible to run the system. The operating system is responsible for creating the environment so that the application software can run. The operating system is a system program that constantly runs on the computer system until the computer system is shut down. It is the first program. The operating system is ready to execute programs once it has been loaded into the primary memory. In the operating system, kernel is an essential program. The kernel is needed for the operation of the operating system. Process management, storage management, memory management, security, and privacy are all responsibilities of the operating system. Interrupts that arise during the execution of the program are often handled by the operating system. Functions of the Operating System The following are the functions of the operating system: 1. Security Security is one of the operating system functions. In order to secure user data, the operating system uses password protection and other similar methods. It also protects programs and user data from unauthorized access. 2. Job Accounting The operating system maintains the track of time and resources, which are used for several tasks and users, this data can be utilized to monitor resource utilization for a specific client or group of clients. 3. Coordination Between Other Software and Users It is also responsible for coordinating and assigning interpreters, assemblers, compilers, and other software to several computer users. 4. Control Over System Performance It monitors the overall health of the system in order to enhance performance. To get a full view of the system's health, monitor the response time it takes between service requests and system response. With the help of the operating system, performance can be improved by providing critical information required to troubleshoot issues. 5. Error Detecting Aids Another feature of the operating system is error detection aids. The operating system continuously tracks the system in order to detect errors and prevent computer system failure. 6. File Management For efficient navigation and use, a file system is structured into directories. Other directories and files can be comprised in these directories. An operating system performs the following file management tasks. It keeps track of where data is stored, the status of each file, and the access setting. These facilities are cooperatively known as the file system. 7. Processor Management In a multi programming environment, the OS takes the decision related to which processes are prioritized and how much processing time they get. This operating system's function is known as process scheduling. An operating system performs the following tasks for processor management. Observe how processes are progressing. The traffic controller is the name of the program that performs this.\n\nAllocates the CPU to the process.\n\nIf the process is no longer required, then the processor will be deallocated. 8. Device Management An operating system (OS) controls computer communication by drivers. It performs the below activities for device management: Maintain the track of all the devices which are connected to the system.\n\nDetermines which processes are allowed access to a computer and for how much time.\n\nAllocates devices in a way that is both effective and efficient, when a computer is no longer needed. Difference between Kernel and Operating System\n\nS.NO Kernel Operating System 1. The kernel is a part of the operating system and it is system software. An operating system is a system software. 2. The kernel serves as an interface between application and hardware. The operating system serves as an interface between the user and hardware. 3. A Kernel is needed in order to run each operating system. The Operating system is needed in order to run each system. 4. The kernel comes in two varieties Monolithic and Micro Kernel. Operating systems come in a variety of flavors, including Distributed OS, Realtime OS, Single and Multiuser OS, and Multiprocessor OS. 5. When the operating system loads, it is the first program to run. When the computer system boots up, the operating system is the first program to load. 6. The main purpose of the kernel is task management, memory management, process management, and disk management. The operating system offers security and protection. Next Topic Difference Between\n\n\n\n\u2190 prev next \u2192\n\n\n\n"}]}