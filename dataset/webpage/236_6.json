{"Ted Childs was responsible for the development of the Windows user interface.": [{"url": "https://www.britannica.com/technology/Microsoft-Windows", "page_content": "Microsoft Windows, also called Windows and Windows OS, computer operating system (OS) developed by Microsoft Corporation to run personal computers (PCs). Featuring the first graphical user interface (GUI) for IBM-compatible PCs, the Windows OS soon dominated the PC market. Approximately 90 percent of PCs run some version of Windows.\n\nThe first version of Windows, released in 1985, was simply a GUI offered as an extension of Microsoft\u2019s existing disk operating system, or MS-DOS. Based in part on licensed concepts that Apple Inc. had used for its Macintosh System Software, Windows for the first time allowed DOS users to visually navigate a virtual desktop, opening graphical \u201cwindows\u201d displaying the contents of electronic folders and files with the click of a mouse button, rather than typing commands and directory paths at a text prompt.\n\nBritannica Quiz Computers and Operating Systems\n\nSubsequent versions introduced greater functionality, including native Windows File Manager, Program Manager, and Print Manager programs, and a more dynamic interface. Microsoft also developed specialized Windows packages, including the networkable Windows for Workgroups and the high-powered Windows NT, aimed at businesses. The 1995 consumer release Windows 95 fully integrated Windows and DOS and offered built-in Internet support, including the World Wide Web browser Internet Explorer.\n\nWith the 2001 release of Windows XP, Microsoft united its various Windows packages under a single banner, offering multiple editions for consumers, businesses, multimedia developers, and others. Windows XP abandoned the long-used Windows 95 kernel (core software code) for a more powerful code base and offered a more practical interface and improved application and memory management. The highly successful XP standard was succeeded in late 2006 by Windows Vista, which experienced a troubled rollout and met with considerable marketplace resistance, quickly acquiring a reputation for being a large, slow, and resource-consuming system. Responding to Vista\u2019s disappointing adoption rate, Microsoft in 2009 released Windows 7, an OS whose interface was similar to that of Vista but was met with enthusiasm for its noticeable speed improvement and its modest system requirements.\n\nWindows 8 in 2012 offered a start screen with applications appearing as tiles on a grid and the ability to synchronize settings so users could log on to another Windows 8 machine and use their preferred settings. In 2015 Microsoft released Windows 10, which came with Cortana, a digital personal assistant like Apple\u2019s Siri, and the Web browser Microsoft Edge, which replaced Internet Explorer. Microsoft also announced that Windows 10 would be the last version of Windows, meaning that users would receive regular updates to the OS but that no more large-scale revisions would be done."}, {"url": "https://www.theguardian.com/technology/2014/oct/02/from-windows-1-to-windows-10-29-years-of-windows-evolution", "page_content": "Microsoft Windows has seen nine major versions since its first release in 1985. Over 29 years later, Windows looks very different but somehow familiar with elements that have survived the test of time, increases in computing power and \u2013 most recently \u2013 a shift from the keyboard and mouse to the touchscreen.\n\nHere\u2019s a brief look at the history of Windows, from its birth at the hands of Bill Gates with Windows 1 to the latest arrival under new Microsoft chief executive Satya Nadella.\n\nWindows 1\n\nThe first version of Windows. Photograph: Wikipedia\n\nThis is where it all started for Windows. The original Windows 1 was released in November 1985 and was Microsoft\u2019s first true attempt at a graphical user interface in 16-bit.\n\nDevelopment was spearheaded by Microsoft founder Bill Gates and ran on top of MS-DOS, which relied on command-line input.\n\nIt was notable because it relied heavily on use of a mouse before the mouse was a common computer input device. To help users become familiar with this odd input system, Microsoft included a game, Reversi (visible in the screenshot) that relied on mouse control, not the keyboard, to get people used to moving the mouse around and clicking onscreen elements.\n\nWindows 2\n\nWindows 2 with overlapping windows. Photograph: Wikipedia\n\nTwo years after the release of Windows 1, Microsoft\u2019s Windows 2 replaced it in December 1987. The big innovation for Windows 2 was that windows could overlap each other, and it also introduced the ability to minimise or maximise windows instead of \u201ciconising\u201d or \u201czooming\u201d.\n\nThe control panel, where various system settings and configuration options were collected together in one place, was introduced in Windows 2 and survives to this day.\n\nMicrosoft Word and Excel also made their first appearances running on Windows 2.\n\nWindows 3\n\nWindows 3.0 got colourful.\n\nThe first Windows that required a hard drive launched in 1990. Windows 3 was the first version to see more widespread success and be considered a challenger to Apple\u2019s Macintosh and the Commodore Amiga graphical user interfaces, coming pre-installed on computers from PC-compatible manufacturers including Zenith Data Systems.\n\nWindows 3 introduced the ability to run MS-DOS programmes in windows, which brought multitasking to legacy programmes, and supported 256 colours bringing a more modern, colourful look to the interface.\n\nMore important - at least to the sum total of human time wasted - it introduced the card-moving timesink (and mouse use trainer) Solitaire.\n\nWindows 3.1\n\nWindows 3.1 with Minesweeper. Photograph: Wikipedia\n\nWindows 1 and 2 both had point release updates, but Windows 3.1 released in 1992 is notable because it introduced TrueType fonts making Windows a viable publishing platform for the first time.\n\nMinesweeper also made its first appearance. Windows 3.1 required 1MB of RAM to run and allowed supported MS-DOS programs to be controlled with a mouse for the first time. Windows 3.1 was also the first Windows to be distributed on a CD-ROM, although once installed on a hard drive it only took up 10 to 15MB (a CD can typically store up to 700MB).\n\nWindows 95\n\nWindows 95: oh hello Start menu.\n\nAs the name implies, Windows 95 arrived in August 1995 and with it brought the first ever Start button and Start menu (launched with a gigantic advertising campaign that used the Rolling Stones\u2019 Start Me Up, and a couple of months later Friends stars Jennifer Aniston and Matthew Perry. Could it be any more up-to-date?)\n\nIt also introduced the concept of \u201cplug and play\u201d \u2013 connect a peripheral and the operating system finds the appropriate drivers for it and makes it work. That was the idea; it didn\u2019t always work in practice.\n\nWindows 95 also introduced a 32-bit environment, the task bar and focused on multitasking. MS-DOS still played an important role for Windows 95, which required it to run some programmes and elements.\n\nInternet Explorer also made its debut on Windows 95, but was not installed by default requiring the Windows 95 Plus! pack. Later revisions of Windows 95 included IE by default, as Netscape Navigator and NCSA Mosaic were popular at the time.\n\nWindows 98\n\nWindows 98, the last great DOS-based Windows. Photograph: Wikipedia\n\nReleased in June 1998, Windows 98 built on Windows 95 and brought with it IE 4, Outlook Express, Windows Address Book, Microsoft Chat and NetShow Player, which was replaced by Windows Media Player 6.2 in Windows 98 Second Edition in 1999.\n\nWindows 98 introduced the back and forward navigation buttons and the address bar in Windows Explorer, among other things. One of the biggest changes was the introduction of the Windows Driver Model for computer components and accessories \u2013 one driver to support all future versions of Windows.\n\nUSB support was much improved in Windows 98 and led to its widespread adoption, including USB hubs and USB mice.\n\nWindows ME\n\nWindows ME was one to skip. Photograph: Wikipedia\n\nConsidered a low point in the Windows series by many \u2013 at least, until they saw Windows Vista \u2013 Windows Millennium Edition was the last Windows to be based on MS-DOS, and the last in the Windows 9x line.\n\nReleased in September 2000, it was the consumer-aimed operating system twined with Windows 2000 aimed at the enterprise market. It introduced some important concepts to consumers, including more automated system recovery tools.\n\nIE 5.5, Windows Media Player 7 and Windows Movie Maker all made their appearance for the first time. Autocomplete also appeared in Windows Explorer, but the operating system was notorious for being buggy, failing to install properly and being generally poor.\n\nWindows 2000\n\nWindows 2000 was ME\u2019s enterprise twin. Photograph: Wikipedia\n\nThe enterprise twin of ME, Windows 2000 was released in February 2000 and was based on Microsoft\u2019s business-orientated system Windows NT and later became the basis for Windows XP.\n\nMicrosoft\u2019s automatic updating played an important role in Windows 2000 and became the first Windows to support hibernation.\n\nWindows XP\n\nWindows XP still survives to this day. Photograph: Schrift-Architekt/flickr\n\nArguably one of the best Windows versions, Windows XP was released in October 2001 and brought Microsoft\u2019s enterprise line and consumer line of operating systems under one roof.\n\nIt was based on Windows NT like Windows 2000, but brought the consumer-friendly elements from Windows ME. The Start menu and task bar got a visual overhaul, bringing the familiar green Start button, blue task bar and vista wallpaper, along with various shadow and other visual effects.\n\nClearType, which was designed to make text easier to read on LCD screens, was introduced, as were built-in CD burning, autoplay from CDs and other media, plus various automated update and recovery tools, that unlike Windows ME actually worked.\n\nWindows XP was the longest running Microsoft operating system, seeing three major updates and support up until April 2014 \u2013 13 years from its original release date. Windows XP was still used on an estimated 430m PCs when it was discontinued.\n\nIts biggest problem was security: though it had a firewall built in, it was turned off by default. Windows XP\u2019s huge popularity turned out to be a boon for hackers and criminals, who exploited its flaws, especially in Internet Explorer, mercilessly - leading Bill Gates to initiate a \u201cTrustworthy Computing\u201d initiative and the subsequent issuance of to Service Pack updates that hardened XP against attack substantially.\n\nWindows Vista\n\nWindows Vista, arguably worse than Windows ME. Photograph: Microsoft\n\nWindows XP stayed the course for close to six years before being replaced by Windows Vista in January 2007. Vista updated the look and feel of Windows with more focus on transparent elements, search and security. Its development, under the codename \u201cLonghorn\u201d, was troubled, with ambitious elements abandoned in order to get it into production.\n\nIt was buggy, burdened the user with hundreds of requests for app permissions under \u201cUser Account Control\u201d - the outcome of the Trustworthy Computing initiative which now meant that users had to approve or disapprove attempts by programs to make various changes. The problem with UAC was that it led to complacency, with people clicking \u201cyes\u201d to almost anything - taking security back to the pre-UAC state. It also ran slowly on older computers despite them being deemed as \u201cVista Ready\u201d - a labelling that saw it sued because not all versions of Vista could run on PCs with that label.\n\nPC gamers saw a boost from Vista\u2019s inclusion of Microsoft\u2019s DirectX 10 technology.\n\nWindows Media Player 11 and IE 7 debuted, along with Windows Defender an anti-spyware programme. Vista also included speech recognition, Windows DVD Maker and Photo Gallery, as well as being the first Windows to be distributed on DVD. Later a version of Windows Vista without Windows Media Player was created in response to anti-trust investigations.\n\nWindows 7\n\nWindows 7 was everything Windows Vista should have been. Photograph: Wikipedia\n\nConsidered by many as what Windows Vista should have been, Windows 7 was first released in October 2009. It was intended to fix all the problems and criticism faced by Vista, with slight tweaks to its appearance and a concentration on user-friendly features and less \u201cdialogue box overload\u201d.\n\nIt was faster, more stable and easier to use, becoming the operating system most users and business would upgrade to from Windows XP, forgoing Vista entirely.\n\nHandwriting recognition debuted in 7, as did the ability to \u201csnap\u201d windows to the tops or sides of the screen, allowing faster more automatic window resizing.\n\nWindows 7 saw Microsoft hit in Europe with antitrust investigations over the pre-installing of IE, which led to a browser ballot screen being shown to new users allowing them to choose, which browser to install on first boot.\n\nWindows 8\n\nWindows 8 focused more on touch than a keyboard and mouse.\n\nReleased in October 2012, Windows 8 was Microsoft\u2019s most radical overhaul of the Windows interface, ditching the Start button and Start menu in favour of a more touch-friendly Start screen.\n\nThe new tiled interface saw programme icons and live tiles, which displayed at-a-glance information normally associated with \u201cwidgets\u201d, replace the lists of programmes and icons. A desktop was still included, which resembled Windows 7.\n\nWindows 8 was faster than previous versions of Windows and included support for the new, much faster USB 3.0 devices. The Windows Store, which offers universal Windows apps that run in a full-screen mode only, was introduced. Programs could still be installed from third-parties like other iterations of Windows, but they could only access the traditional desktop interface of Windows.\n\nThe radical overhaul was not welcomed by many. Microsoft attempted to tread a fine line between touchscreen support and desktop users, but ultimately desktop users wanting to control Windows with a traditional mouse and keyboard and not a touchscreen felt Windows 8 was a step back. There were also too few touchscreens in use, or on offer, to make its touch-oriented interface useful or even necessary - despite the parallel rise of tablets such as the iPad, and smartphones, which had begun outselling PCs by the end of 2010.\n\nWindows RT, which runs on ARM-based processors traditionally found in smartphones and non-PC tablets, was introduced at the same time as Windows 8 with the Microsoft Surface tablet. It looked and felt like Windows 8, but could not run traditional Windows applications, instead solely relying on the Windows Store for third-party apps.\n\nWindows 8.1\n\nWindows 8.1 and the great reappearance of the Start button.\n\nA free point release to Windows 8 introduced in October 2013, Windows 8.1 marked a shift towards yearly software updates from Microsoft and included the first step in Microsoft\u2019s U-turn around its new visual interface.\n\nWindows 8.1 re-introduced the Start button, which brought up the Start screen from the desktop view of Windows 8.1. Users could also choose to boot directly into the desktop of Windows 8.1, which was more suitable for those using a desktop computer with a mouse and keyboard than the touch-focused Start screen.\n\nWindows 10\n\nWindows 10 brings back the Start menu\n\nAnnounced on 30 September 2014, Windows 10 has only been released as a test version for keen users to try. The \u201ctechnical preview\u201d is very much still a work in progress.\n\nWindows 10 represents another step in Microsoft\u2019s U-turn, bringing back the Start menu and more balance to traditional desktop computer users.\n\nSome interesting features include the ability to switch between a keyboard and mouse mode and a tablet mode, for those computers like the Surface Pro 3 with a detachable keyboard.\n\nWindows 10 \u2013 despite being the ninth version of Windows \u2013 is designed to unify all Windows platforms across multiple devices, including Windows Phone and tablets, with universal apps that can be downloaded from the Windows Store and run on all Windows devices.\n\nIt won\u2019t be available until 2015, likely after Microsoft\u2019s Build developer conference in April, so for now Windows 8.1 is the latest version of Windows.\n\nMicrosoft unveils Windows 10: ten things to know"}, {"url": "https://link.springer.com/chapter/10.1007/978-1-4302-6775-1_10", "page_content": "Windows Store apps may be run on devices of varying sizes\u2014from 10\" tablets to desktop systems leveraging full-size monitors, as well device orientation. Tablets may be run in portrait or landscape mode, so it\u2019s natural to consider which orientation your application will support.\n\nIn addition to screen size and orientation, applications must also consider the available screen real estate. As mentioned earlier in this chapter, Windows Store applications may run full-screen or be snapped in a pane that can be resized to various widths. The minimum width for which you must design depends on the supported minimum width set within the application\u2019s manifest file, Package.appxmanifest, as shown in Figure 10-8.\n\nFigure 10-8. Configuring the minimum width supported by the application in the application manifest Full size image\n\nBy default, the minimum supported width will be 500px. If you want to support a width of 320px, simply select that option within the \u201cMinimum width\u201d field in the manifest.\n\nThe application\u2019s height will always occupy the full height of the screen. Only the application width real estate will vary since multiple apps can be run side-by-side and the user will have the ability to resize panes dynamically. Your application must continue to render properly despite the screen size that it is afforded by the user.\n\nWhen designing your Windows Store application, you must determine how your application will look as its available width expands or contracts. As we mentioned in Chapter 8 and Chapter 9, avoid using fixed sizes in your XAML views. Allow the XAML subsystem to adjust automatically to the screen size that your application is afforded by the user.\n\nVisual States\n\nThere will be cases when you will want to ensure that your page renders in a different format when the application window is snapped or resized. You can accomplish this by defining the visual states that your page will support using the VisualState class from the Windows.UI.Xaml namespace. The VisualState class enables you to configure the appearance of a control when it is in a specific state. However, to manage a collection of visual states as well as the logic for transitions between controls, you must make use of the VisualStateManager. Within XAML, you will define one or more visual states using the VisualStateManager.VisualStateGroups collection, as shown in Listing 10-1.\n\nListing 10-1. Configuring Visual States in XAML\n\n<VisualStateManager.VisualStateGroups>\n\n<VisualStateGroup x:Name=\"MyVisualStateGroup\">\n\n<VisualState x:Name=\"Snapped\">\n\n</VisualState>\n\n<VisualState x:Name=\"Narrow\">\n\n</VisualState>\n\n<VisualState x:Name=\"Default\" />\n\n</VisualStateGroup>\n\n</VisualStateManager.VisualStateGroups>\n\nIn the example in Listing 10-1, we have defined three visual states: Snapped, Narrow, and Default. Don\u2019t get too hung up on the names since you can name the visual states using whatever convention makes sense to you. The names you provide here will be referenced in the code-behind, which we will get to shortly.\n\nStoryboards and Animations\n\nOnce you have decided the various widths that you want to support, you must determine how your page will appear in each of those views. For example, if a StackPanel is rendering controls horizontally while the application window is in full view, you may want to change it to render controls vertically when the application is snapped to the left or right edge of the screen. Changing the way the control is rendered can be thought of as a visual transition. Visual transitions can be used to change any Windows Runtime dependency property on a control.\n\nIn XAML, you will be able to define the visual transitions that you want to be applied to a control as it moves from one visual state to another. This is accomplished through the use of storyboards and animations. Animations add movement within your application, providing appealing transitions as property values on a control are changed. Storyboards control the animations that are run using a timeline.\n\nYou can create animations for Color, Double, Point, and Object properties using the animations listed in Table 10-1.\n\nTable 10-1. Windows Runtime Animations Full size table\n\nUsing the example mentioned earlier, Listing 10-2 demonstrates how to change the StackPanel orientation when the window is snapped.\n\nListing 10-2. Configure the StackPanel to Change Orientation When the Page Is Snapped\n\n<VisualStateManager.VisualStateGroups>\n\n<VisualStateGroup x:Name=\"MyVisualStateGroup\">\n\n<VisualState x:Name=\"Snapped\">\n\n<Storyboard>\n\n<ObjectAnimationUsingKeyFrames\n\nStoryboard.TargetName=\"MyStackPanel\"\n\nStoryboard.TargetProperty=\"Orientation\">\n\n<DiscreteObjectKeyFrame KeyTime=\"0\">\n\n<DiscreteObjectKeyFrame.Value>\n\n<Orientation>Vertical</Orientation>\n\n</DiscreteObjectKeyFrame.Value>\n\n</DiscreteObjectKeyFrame>\n\n</ObjectAnimationUsingKeyFrames>\n\n</Storyboard>\n\n</VisualState>\n\n...\n\n</VisualStateGroup>\n\n</VisualStateManager.VisualStateGroups>\n\nListing 10-2 demonstrates the use of the ObjectAnimationUsingKeyFrames class to transition the StackPanel from horizontal to vertical orientation by defining the StackPanel\u2019s new orientation property within the DiscreteObjectKeyFrame.Value element.\n\n<DiscreteObjectKeyFrame KeyTime=\"0\">\n\n<DiscreteObjectKeyFrame.Value>\n\n<Orientation>Vertical</Orientation>\n\n</DiscreteObjectKeyFrame>\n\nThe number of animations that you want to include within a single storyboard is not limited. You can change as many property values as you need there. For example, if you also wanted reduce the text size of the Title text block when the window is snapped, you could include an additional animation in the storyboard definition for the Snapped visual state as follows:\n\n<DoubleAnimation Duration=\"0\"\n\nTo=\"21\"\n\nStoryboard.TargetProperty=\"FontSize\"\n\nStoryboard.TargetName=\"TitleTextBlock\" />\n\nNote that, in this case, the FontSize is changed through the To property on the DoubleAnimation element.\n\nWhen configuring an animation for a specific control, you must specify the target control\u2019s name and the property to which the animation must be applied. You can accomplish this by setting the attached properties TargetName and TargetProperty on the animation: <ObjectAnimationUsingKeyFrames Storyboard.TargetName=\"MyStackPanel\" Storyboard.TargetProperty=\"Orientation\">.\n\nNotice that when the TargetName has been configured, the TargetProperty will automatically populate its selection list with only those properties that are applicable to the target UI element, enabling you to have complete control over the appearance of any object within the page.\n\nYou must also specify a Duration or KeyTime to indicate how long the animation will take to complete. When defining a duration for a visual state transition, use zero-duration animations to ensure that the application remains responsive. Setting a longer duration may negatively affect performance on the UI thread and lock up the application until the animation completes.\n\nOnSizeChanged\n\nNow that you know how you can define a view for each of the visual states that your application will support, how does the VisualStateManager know how to render the page?\n\nTo ensure the appropriate visual state is rendered when the application window\u2019s width is resized, you must register for the Page\u2019s OnSizeChanged event. The OnSizeChanged event receives the SizeChangedEventArgs parameter, which exposes two Size properties: NewSize and PreviousSize. You can use these properties to retrieve the Height and Width of the application window before and after it was resized.\n\nWithin the OnSizeChanged event, you will need to call the VisualStateManager.GoToState method, passing in the desired visual state to render. In this case, you will use the e.NewSize.Width property to determine which visual state to render. You must decide the maximum width that each visual state will support. Will a width of 500px or less trigger your Snapped view, or will it be 320px? What will the next maximum supported width be after that? These are design considerations that you must define based on your application. Listing 10-3 demonstrates an example of how to trigger the appropriate visual state based on the window\u2019s new width size.\n\nListing 10-3. The OnSizeChanged Event Will Be Used to Trigger the Appropriate VisualState Through the VisualStateManager\n\n//custom enumeration to represent each of\n\n//the custom visual states configured in XAML\n\npublic enum MyVisualStates\n\n{\n\nSnapped,\n\nNarrow,\n\nDefault\n\n}\n\npublic sealed partial class MainPage : Page\n\n{\n\npublic MainPage()\n\n{\n\nthis.InitializeComponent();\n\nthis.SizeChanged += MainPage_SizeChanged;\n\n}\n\nvoid MainPage_SizeChanged(object sender, SizeChangedEventArgs e)\n\n{\n\nVisualStateManager.GoToState(this, GetCustomVisualState(e.NewSize.Width), true);\n\n}\n\nprivate string GetCustomVisualState(double width)\n\n{\n\nif (width <= 500)\n\n{\n\nreturn MyVisualStates.Snapped.ToString();\n\n}\n\nif (width <= 800)\n\n{\n\nreturn MyVisualStates.Narrow.ToString();\n\n}\n\nreturn MyVisualStates.Default.ToString();\n\n}\n\n}\n\nTaking the time to configure visual states within your application will ensure that your users have a seamless experience regardless of the screen real estate that is available to your app at runtime. Although it does require some legwork up front, the end result will be a polished, high-quality application that will be appealing to your users."}, {"url": "https://learn.microsoft.com/en-us/windows/apps/develop/user-interface", "page_content": "Table of contents\n\nUser interface and input\n\nArticle\n\n10/27/2022\n\n6 contributors Feedback\n\nIn this article\n\nThis article provides an overview of the Windows UI frameworks that are currently maintained by Microsoft and compares their capabilities.\n\nMicrosoft produces both UI frameworks and app platforms. App platforms typically include a UI framework, while UI frameworks are either standalone (not shipped with an app platform) or can be used with multiple app platforms (see Choose your app platform).\n\nThe frameworks discussed here include the Windows UI Library (WinUI) for both Windows App SDK (WinUI 3) and UWP (WinUI 2), Windows Presentation Foundation (WPF), and Windows Forms (WinForms).\n\nUser interface fundamentals\n\nWhen building a modern Windows app, you have a selection of UI frameworks to choose from. UI frameworks provide your app with built in controls, styles, animations, input handling, and more.\n\nThere are five main components that go into creating a user interface for your Windows app. These components are usually built into each UI framework.\n\nControls and styles A control is a UI element that displays content or enables interaction. Controls are the building blocks of the user interface. Here's an example of a Button control that's available in UWP, WinUI 2, and WinUI 3. When you place this control into your app, it automatically receives the default design that the UI framework provides. Styles consist of colors, typography, icons, Fluent materials, and more that can be used throughout your app's design to create a truly unique experience. Here's an example of a style component called Acrylic, available in WinUI 2 and WinUI 3. Acrylic is a brush that you can use on surfaces within your app or as the background of your app. It provides a translucent texture.\n\nInput and interaction End users may interact with your app and provide input to your app (such as selection or typing) through different methods. Some examples of input are: Mouse Touch Gamepad Pen Keyboard Surface Dial Touchpad Speech\n\nDevice support End users access Windows apps on a variety of devices, and UI frameworks may only support certain ones. Some common devices for Windows apps to run on are: PCs (often referred to as \"desktop\", but includes laptops as well) Tablets HoloLens Xbox Surface Hub\n\nMotion and animation Built-in animations can really give your app a polished look and feel, and provide consistency with first-party apps throughout Windows. An example of a built-in animation in UWP, WinUI 2, and WinUI 3 is the animation that occurs when the end user switches between light and dark mode. When the end user switches modes for their entire PC, the app's UI will automatically update as well with a transition animation.\n\nUsability and accessibility In order to ensure your app is delightful to use for every single user, you must take accessibility into account. UI frameworks provide built-in accessibility to controls and styles with purposeful keyboard behavior, screenreader support and more. Many also provide APIs for accessible actions in custom controls, like interacting with screenreaders.\n\nUI frameworks\n\nEach UI framework released by Microsoft has unique capabilities, follows different design languages, and provides different experiences to the end user. This section will compare all the main UI frameworks that you'll be choosing from when you begin to build your app.\n\nThe table below shows a brief summary of a few main capabilities between these UI frameworks. For more details on each framework, navigate through the tabs further below.\n\nCapability Windows App SDK (WinUI 3) WinUI 2 for UWP WPF WinForms Languages supported C#/.NET 6 and later, C++/WinRT C#/.NET Native, C++/WinRT, C++/CX, VB C#/.NET 6 (and later) and .NET Framework, C++/CLI (Managed Extensions for C++), F#, VB C#/.NET 6 (and later) and .NET Framework, C++/CLI (Managed Extensions for C++), F#, VB Devices supported PCs (incl. laptops and tablets), support for all Windows 10 devices coming soon All Windows 10 devices (PCs, tablets, HoloLens, Xbox, Surface Dial, and more) Desktop PCs and laptops Desktop PCs and laptops Inputs supported All Windows 10 inputs supported All Windows 10 inputs supported Mouse and keyboard Mouse and keyboard Windows OS version supported Windows 10 version 1809 or later Windows 10 version 1703 or later Windows XP or later Windows XP or later WebView support Chromium-based WebView2 Non-chromium WebView WebView2 support coming soon WebView2 support coming soon Open Source Coming soon Yes Yes (.NET 6 and later only) Yes (.NET 6 and later only)\n\nFor more information about each of these UI frameworks, see the information on the following tabs."}, {"url": "https://dl.acm.org/doi/fullHtml/10.1145/238386.238611", "page_content": "The Windows\u00ae 95 User Interface: A Case Study in Usability Engineering\n\nKent Sullivan\n\nMicrosoft Corporation\n\nOne Microsoft Way\n\nRedmond, WA 98052-6399\n\n+1 206 936 3568\n\nkentsu@microsoft.com\n\nABSTRACT\n\nThe development of the user interface for a large commercial software product like Microsoft\u00ae Windows 95 involves many people, broad design goals, and an aggressive work schedule. This design briefing describes how the usability engineering principles of iterative design and problem tracking were successfully applied to make the development of the UI more manageable. Specific design problems and their solutions are also discussed.\n\nKeywords\n\nIterative design, Microsoft Windows, problem tracking, rapid prototyping, usability engineering, usability testing.\n\nINTRODUCTION\n\nWindows 95 is a comprehensive upgrade to the Windows 3.1 and Windows for Workgroups 3.11 products. Many changes have been made in almost every area of Windows, with the user interface being no exception. This paper discusses the design team, its goals and process then explains how usability engineering principles such as iterative design and problem tracking were applied to the project, using specific design problems and their solutions as examples.\n\nDesign Team\n\nThe Windows 95 user interface design team was formed in October, 1992 during the early stages of the project. I joined the team as an adjunct member, to provide usability services, in December 1992. The design team was truly interdisciplinary, with people trained in product design, graphic design, usability testing, and computer science. The number of people oscillated during the project but was approximately twelve. The software developers dedicated to implementing the user interface accounted for another twelve or so people.\n\nDesign Goals\n\nThe design team was chartered with two very broad goals:\n\nMake Windows easier to learn for people just getting started with computers and Windows.\n\nfor people just getting started with computers and Windows. Make Windows easier to use for people who already use computers-both the typical Windows 3.1 user and the advanced, or \"power\", Windows 3.1 user.\n\nWith over 50 million units of Windows 3.1 and 3.11 installed plus a largely-untapped home market, it was clear from the outset that the task of making a better product was not going to be a trivial exercise. Without careful design and testing, we were likely to make a product that improved usability for some users and worsened it for millions of other users (existing or potential). We understood fairly well the problems that intermediate and advanced users had but we knew little about problems beginning users had.\n\nDesign Process\n\nGiven very broad design goals and an aggressive schedule for shipping the product (approximately 18 months to design and code the user interface) we knew from the outset that a traditional \"waterfall\" style development process would not allow us sufficient flexibility to attain the best-possible solution. In fact, we were concerned that the traditional approach would yield a very unusable system.\n\nIn the \"waterfall\" approach, the design of the system is compartmentalized (usually limited to a specification writing phase) and usability testing typically occurs near the end of the process, during quality assurance activities. We recognized that we needed much more opportunity to create a design, try it out with users (perhaps comparing it to other designs), make changes, and gather more user feedback. Our desire to abandon the waterfall model and opt for iterative design fortunately followed similar efforts in other areas of the company, so we had concrete examples of its benefits and feasibility.\n\nITERATIVE DESIGN IN PRACTICE\n\nFigure 1 outlines the process that we used. The process was typical of most products designed iteratively: paper or computer-based prototypes were used to try out design ideas and to gather usability data in the lab. Once a design had been coded, it was refined in the usability lab. When enough of the product had been coded and refined, it was examined more broadly, over time, in the field. Minor usability problems identified in the field were fixed before shipping the product. More importantly, the data gathered in the field is being used to guide work on the next version.\n\nOur iterative design process was divided into three major phases: exploration, rapid prototyping, and fine tuning.\n\nFigure 1: Windows 95 iterative design process.\n\nExploration Phase\n\nIn this first phase we experimented with design directions and gathered initial user data. We began with a solid foundation for the visual design of the user interface by leveraging work done by the \"Cairo\" team. We inherited from them much of the fundamental UI and interaction design (the desktop, the \"Tray\", context menus, three-dimensional look and feel, etc.). We also collected data from product support about users' top twenty problems with Windows 3.1.\n\nFigure 2 shows a prototype Windows 95 desktop design that we usability tested in January 1993. This design was based on Cairo and incorporated a first pass at fixing some of the known problems with Windows 3.1 (window management in particular).\n\nFigure 2: Early Windows 95 desktop (with callouts to enhance clarity).\n\nThe top icon, File Cabinet, showed a Windows 3.1 File Manager-type view (left pane shows hierarchy, right pane show contents). The second icon, World, showed items on the network. The third icon, Programs, was a folder which contained other folders full of links to programs on the computer. Along the bottom was the \"Tray\", which featured three buttons (System, Find, and Help) and a file storage area. Another icon, Wastebasket, was a container for deleted files.\n\nThe usability studies of the prototype desktop were conducted in the Microsoft usability lab, as were later tests. We conducted typical iterative usability studies. Three to four users representing each distinct group of interest (typically beginning and intermediate Windows 3.1 users) completed tasks which exercised the prototype. Questions we addressed in testing were sometimes very broad (e.g., \"Do users like it?\") and sometimes very specific (e.g., \"After ten minutes of use, do users discover drag and drop to copy a file?\"). We collected data typical for iterative studies: verbal protocols, time per task, number of errors, types of errors, and rating information.\n\nEarly Findings\n\nOur usability testing of this prototype revealed much including several surprises:\n\nBeginning users and many intermediates were confused by the two-pane view of File Cabinet. (See Figure 3.) They were unsure of the relationship between the panes and how to navigate between folders. Beginners were often overwhelmed by the visual complexity of the File Cabinet and had more basic problems, such as not understanding how folders could exist inside of other folders. Many users were also confused by the Parent Folder icon. It appeared in every folder and looked like a file, yet was really a navigation control for moving up the hierarchy one level.\n\nFigure 3: File Cabinet, an early file system viewer.\n\nUsers of every type were confused by the Programs folder. We thought that having a folder on the desktop with other folders and links to programs inside it would be a natural transition for Windows 3.1 users accustomed to Program Manager, while being relatively easy to learn for beginners. We were wrong! Beginners quickly got lost in all of the folders (unlike File Cabinet, each folder opened into a different window) and other users had a lot of trouble deciding whether they were looking at the actual file system and its files or just links to actual files.\n\nUsers had considerable difficulty deciding what each of the three buttons on the Tray was for and later had trouble remembering where to go for a particular command because their functions overlapped in certain contexts (e.g., to find something in Help, do you go to Find or to Help?).\n\nComparison to Windows 3.1\n\nFrom the first lab studies it became clear that we needed a baseline with Windows 3.1, to better understand what problems existed prior to Windows 95 and what problems were unique to the new design. First, we gathered market research data about Windows 3.1 users' twenty most-frequent tasks. We then conducted several lab studies comparing Windows 3.1 and Windows 95, focusing on the top twenty tasks derived from the market research data. We also interviewed professional Windows 3.1 (and Macintosh, for comparison) educators, to learn what they found easy and difficult to teach about the operating system.\n\nThe key findings were:\n\nIn Windows 3.1, beginning users took over 9 \u00bd minutes, on average, to locate and open a program that was not immediately visible. Results were not much better for our Windows 95 prototype. These results were clearly unacceptable, given that our market research data (and common sense) told us that starting a program was users' number one task.\n\nBeginning users and some intermediates had a lot of trouble using the mouse, especially double-clicking. As a result, they often failed to find things in containers when the only way to open them was double-clicking.\n\nBeginning users and many intermediates relied almost exclusively on visible cues for finding commands. They relied on (and found intuitive) menu bars and tool bars, but did not use pop-up (or \"context\") menus, even after training.\n\nAll but the most advanced users did not understand how to manage overlapping windows efficiently. Beginners had the most trouble-when they minimized a window, they considered it \"gone\" if it was obscured by another window. We heard many stories from educators (and witnessed in the lab) how users caused the computer to run out of RAM by starting multiple copies of a program instead of switching back to the first copy. Intermediate users were more proficient but still had trouble, especially with Multiple-Document-Interface (MDI) applications such as Program Manager and Microsoft Word. Market research data confirmed the problem by revealing that 40% of intermediate Windows users didn't run more than one program at a time because they had some kind of trouble with the process.\n\nBeginning users were bewildered by the hierarchical file system. Intermediate users could get around in the hierarchy, but often just barely, and usually saved all of their documents in the default directory for the program they were using. This problem (especially the novice case) was also observed with Macintosh users.\n\nA Change of Direction\n\nThe results from these studies and interviews greatly changed the design of the Windows 95 UI. In the early Windows 95 prototype, we had purposefully changed some things from Windows 3.1 (e.g., the desktop was now a real container) but not others (e.g., File Manager and Program Manager-like icons on desktop) because we were afraid of going too far with the design. We were aware that creating a product which was radically different from Windows 3.1 could confuse and disappoint millions of existing users, which would clearly be unacceptable.\n\nHowever, the data we collected with the Windows 95 prototype and with Windows 3.1 showed us that we couldn't continue down the current path. The results with beginning users on basic tasks were unacceptably poor and many intermediate users thought that Windows 95 was just different, not better.\n\nWe decided to step back and take a few days to think about the situation. The design team held an offsite retreat and reviewed all the data collected to date: baseline usability studies, interviews, market research, and product support information. As we discussed the data, we realized that we needed to focus on users' most-frequent tasks. We also realized that we had been focusing too much on consistency with Windows 3.1.\n\nEssentially, we realized that a viable solution might not look or act like Windows 3.1 but would definitely provide enough value to be attractive for users of all levels, for potentially different reasons. We realized that a truly usable system would scale to the needs of different users: it would be easy to discover and learn yet would provide efficiency (through shortcuts and alternate methods) for more-experienced users.\n\nRapid Iteration Phase\n\nAs we started working on new designs, we hoped to avoid the classic \"easy to learn but hard to use\" paradox by always keeping in mind that the basic features of the UI must scale. To achieve this goal, we knew we needed to try many different ideas quickly, compare them, and iterate those which seemed most promising. To do this, we needed to make our design and evaluation processes very efficient.\n\nUI Specification Process Evolution\n\nAlthough we had opted for an iterative design approach from the beginning, one legacy of the waterfall design approach remained: the monolithic design specification (\"spec\"). During the first few months of the project, the spec had grown by leaps and bounds and reflected hundreds of person-hours of effort. However, due to the problems we found via user testing, the design documented in the spec was suddenly out of date. The team faced a major decision: spend weeks changing the spec to reflect the new ideas and lose valuable time for iterating or stop updating the spec and let the prototypes and code serve as a \"living\" spec.\n\nAfter some debate, the team decided to take the latter approach. While this change made it somewhat more difficult for outside groups to keep track of what we were doing, it allowed us to iterate at top speed. The change also had an unexpected effect: it brought the whole team closer together because much of the spec existed in conversations and on white boards in people's offices. Many \"hallway\" conversations ensued and continued for the duration of the project.\n\nTo ensure that interested parties stayed informed about the design, we:\n\nHeld regular staff meetings for the design team . These weekly (sometimes more often) meetings allowed each of us to check in about what we were doing and to efficiently discuss how what one person was working on affected other work. Broadcasted usability test schedules and results via electronic mail . Design team members received regular notification of upcoming usability tests and results from completed tests so they could more easily keep abreast of the usability information and how the design was evolving. Formally tracked usability issues . With a project the size of Windows 95, we knew we needed a standard way to note all of the usability issues identified, record when and how they were to be fixed, and then close them once the fix was implemented and tested successfully with users. This process is discussed more in the \"Keeping Track of Open Issues\" section. Held regular design presentations for outside groups . As the project progressed, more and more groups (inside and outside Microsoft) wanted to know what we were doing, so we showed them and demonstrated what we were working on. These presentations were more effective than a written document, because the presentations were easier to keep up-to-date and allowed timely design discussions.\n\nSeparate UI for Beginners\n\nThe first major design direction we investigated was a separate UI (\"shell\") for beginning users. The design was quickly mocked up in Visual Basic and tested in the usability lab. (See Figure 4.) While the design tested well, because it successfully constrained user actions to a very small set, we quickly began to see the limitations as more users were tested:\n\nIf just one function a user needed was not supported in the beginner shell, s/he would have to abandon it (at least temporarily). Assuming that most users would gain experience and want to leave the beginner shell eventually, the learning they had done would not necessarily transfer well to the standard shell. The beginner shell was not at all like the programs users would run (word processors, spreadsheets, etc.). As a result, users had to learn two ways of interacting with the computer, which was confusing.\n\nFigure 4: Partial view of separate shell for beginners.\n\nFor these reasons and others, we abandoned the idea. Importantly, because we used a prototyping tool and tested immediately in the usability lab, we still had plenty of time to investigate other directions.\n\nRapid Iteration Examples\n\nBelow are overviews of five areas where we designed and tested three or more major design iterations. There are many more areas for which there is not adequate space to discuss.\n\nLaunching Programs: Start Menu . Although we abandoned the idea of a separate shell for beginners, we salvaged its most useful features: single-click access, high visibility, and menu-based interaction. We mocked up a number of representations in Visual Basic and tested them with users of all experience levels, not just beginners, because we knew that the design solution would need to work well for users of varying experience levels. Figure 5 shows the final Start Menu, with the Programs sub-menu open. The final Start Menu integrated functions other than starting programs, to give users a single-button home base in the UI. Figure 5: Start menu with Programs item open. Managing Windows: Task Bar . Our first design idea for making window management easier was not very ambitious, but we weren't sure how much work was needed to solve the problem. The first design was to change the look of minimized windows from icons to \"plates\". (See Figure 6.) We hoped that the problem would be solved by giving minimized windows a distinctive look and by making them larger. We were wrong! Users had almost exactly the same amount of trouble as with Windows 3.1. Our testing data told us that the main problem was windows not being visible at all times, so users couldn't see what they had open or access tasks quickly. This realization led us fairly quickly to the task bar design, shown in Figure 7. Every task has its own entry in the task bar and the bar stays on top of other windows. User testing confirmed that this was a feasible solution to the problem. Figure 6: \"Plate\" visualization for minimized windows. Figure 7: Task bar with Start button, programs, and clock. Working with Files: \"Open\" and \"Save As\" dialogs . Information from product support plus lab testing told us that beginners and intermediates had a lot of trouble using the system-provided dialogs for opening and saving files. (See Figure 8.) The problems stemmed from the fields in the dialog not being in a logical order and having a complex selection methodology. The Cairo team took the lead on this problem and constructed a comprehensive Visual Basic prototype that included a mock file system. We tested many variations until we arrived at the final design shown in Figure 9. Figure 8: Windows 3.1 File.Open dialog box. Figure 9: Windows 95 File.Open dialog box. Printing: Setup Wizard . Product support information told us that printer setup and configuration was the number one call-generator in Windows 3.1. Many of the problems stemmed from the printer setup UI. (See Figure 10.) Searching for a printer was difficult because all printers were in one long list. Choosing a port for the printer, especially in a networked environment, required tunneling down 4-5 levels and featured non-standard and complicated selection behavior. About the time we started work on this problem, members of the design team began investigating wizards as a solution to multi-step, infrequent tasks. Printer setup fit this definition nicely and the resulting wizard tested very well with users. The printer selection screen from the final wizard is shown in Figure 11. Figure 10: Main Windows 3.1 printer setup dialog box. Figure 11: Screen from Windows 95 Add Printer wizard. Getting Help: Search dialog/Index tab . Lab testing of Windows 3.1 showed that users had trouble with the Search dialog in Help. (See Figure 12.) Users had difficulty understanding that the dialog was essentially two parts and that they needed to choose something from the first list and then from the second list, using different buttons. We tried several ideas before arriving at the final Index tab. (See Figure 13.) The Index tab only has one list, and keywords with more than one topic generate a pop-up dialog that users have no trouble noticing.\n\nFigure 12: Windows 3.1 Help.Search dialog.\n\nFigure 13: Windows 95 Help.Index tab.\n\nFine Tuning Phase\n\nOnce we had designed all of the major areas of the product, we realized that we had to take a step back and see how all of the pieces fit together. To accomplish this, we conducted summative lab tests and a longitudinal field study.\n\nSummative lab testing . Using the top twenty tasks identified from market research, we conducted holistic tests of the entire UI. Users of different experience levels completed isomorphic sets of tasks, to measure ease of learning and ease of use once learned. We compared performance with Windows 3.1 as a baseline. After piloting the test in-house to work out problems with the procedure, the test was conducted by an outside vendor, so that the results could be used in a white paper [3]. The results were very encouraging-users finished the tasks in about half the time it took them in Windows 3.1 and they were more satisfied with Windows 95 in 20 of the 21 categories surveyed.\n\n. Using the top twenty tasks identified from market research, we conducted holistic tests of the entire UI. Users of different experience levels completed isomorphic sets of tasks, to measure ease of learning and ease of use once learned. We compared performance with Windows 3.1 as a baseline. After piloting the test in-house to work out problems with the procedure, the test was conducted by an outside vendor, so that the results could be used in a white paper [3]. The results were very encouraging-users finished the tasks in about half the time it took them in Windows 3.1 and they were more satisfied with Windows 95 in 20 of the 21 categories surveyed. Longitudinal field study . Using the final beta of Windows 95, we conducted a 20-person field study. We first examined how users worked with Windows 3.1 then watched them set up Windows 95. We returned after a week and after a month to measure learning and changes in use over time. We did not find any major usability holes in the product but did tweak wording in the UI and in Help topics. Some of the data collected is being used by product planners for the next version of Windows and also by product support, as a concise list of things to watch out for when taking support calls.\n\nKEEPING TRACK OF OPEN ISSUES\n\nThroughout the course of designing and testing the Windows 95 UI, we applied various usability engineering principles and practices [2] [4]. With a project the size of Windows 95, we knew we needed a standard way to note all of the usability issues identified, record when and how they were to be fixed, and then close them once the fix was implemented and tested successfully with users.\n\nWe designed a relational database to meet this need. (See Figure 14.) After every phase of lab testing, I entered new problems as well as positive findings and assigned them to the appropriate owners-usually a designer and a user education person together. The status of existing problems was also updated-either left open if more work was needed or closed if solved. Every couple of weeks I ran a series of reports that printed all of the remaining problems, by owner, and distributed them to the team members. (See Figure 15.) We met to discuss progress on solutions and when the changed designs would be ready to test with users.\n\nFigure 14: Sample tracking database record.\n\nFigure 15: Sample tracking database report.\n\nReport Card\n\nAs with any project, the \"proof is in the pudding\" so sharing some summary statistics is in order.\n\nLab Testing\n\nWe conducted sixty-four phases of lab testing, using 560 subjects. Fifty percent of the users were intermediate Windows 3.1 users; the rest were beginners, advanced users, and users of other operating systems. These numbers do not include testing done on components delivered to us by other teams (Exchange email client, fax software, etc.) Testing on those components accounts for approximately 25 phases and 175 users.\n\nProblem Identification\n\nFor the core shell components, 699 different \"usability statements\" were entered into the database during the project. Of that number, 148 were positive findings and 551 were problems. The problems were rated with one of three levels of severity:\n\nLevel 1: Users were unable to continue with a task or series of tasks due to the problem.\n\nLevel 2: Users had considerable difficulty completing a task or series of tasks but were eventually able to continue.\n\nLevel 3: Users had minor difficulty completing a task or series of tasks.\n\nOf the 551 problems identified, 15% were judged to be level 1, 43% level 2, and 42% level 3.\n\nProblem Resolution\n\nDuring the project, there were five types of resolution:\n\nAddressed. The team fixed the problem and it tested successfully with users. Planned. The team designed a fix for the problem and we are waiting for it to be implemented. Undecided. The team is not sure whether to fix the problem or is unsure if a fix is feasible. Somewhat. The team designed a fix and it was tested with users, and the results were satisfactory but some issues remain. Not Addressed. The team is not going to fix the problem.\n\nBy the end of the project, all problems with resolution \"planned\" or \"undecided\" had migrated to one of the other categories. Eighty-one percent of the problems were resolved \"Addressed\", 8% were resolved \"Somewhat\", and 11% were resolved \"Not Addressed\". Most of the issues that were not addressed were due to a technical limitation, or sometimes a scheduling limitation.\n\nCONCLUSIONS\n\nThe Windows 95 project was the first experience for many of the team members for doing iterative design, usability testing, and problem tracking.\n\nIterative Design\n\nPerhaps the best testament to our belief in iterative design is that literally no detail of the initial UI design for Windows 95 survived unchanged in the final product. At the beginning of the design process, we didn't envision the scope and volume of changes that we ended up making. Iterative design, using prototypes and the product as the spec, and our constant testing with users allowed us to explore many different solutions to problems quickly.\n\nThe design team became so used to iterating on a design that we felt rushed when, near the end of the project, we had to do some last-minute design work. There wasn't sufficient time to iterate more than once. We were disappointed that we didn't have time to continue fine tuning and re-testing the design.\n\nSpecification Process\n\nThe \"prototype or code are the spec\" approach overall worked well, although we naturally have refined the process over time. For example, all the prototypes for a given release of the product now reside in a common location on the network and include instructions for installing and running them.\n\nThe design team continues to write initial specification documents and circulate them for early feedback. Once prototyping and usability testing has begun, however, the spec often refers readers to the prototype for details. We have essentially found that the prototype is a richer type of specification, for less work, since it has other uses (usability testing, demos, etc.). A prototype also invites richer feedback, because the reviewer has to imagine less about how the system would work.\n\nUsability Testing\n\nAlthough doing design and user testing iteratively allowed us to create usable task areas or features of the product, user testing the product holistically was key to polishing the fit between the pieces. As discussed previously, we made changes to wording in the UI and in Help topics based on the data collected. If we had not done this testing, users' overall experience with the product would have been less productive and enjoyable.\n\nProblem Tracking\n\nThe high fix rate for usability problems would not have been possible without the intense dedication of all the team members. The tracking database made the whole process more manageable and ensured that issues didn't slip between the cracks. However, the fixes would not have been made if the team had not believed in making the most-usable product possible. Key to this belief was our understanding that we probably weren't going to get it right the first time and that not getting it right was as useful and interesting to creating a product as getting it right was.\n\nIn the tracking database, all of the issues marked \"Somewhat\" or \"Not Addressed\" were rolled over into a new database, as a starting point for design work on the next version of Windows. Product planners and designers worked with the information on a daily basis, as well as processing reports from product support.\n\nACKNOWLEDGMENTS\n\nThanks to Jane Dailey, Chris Guzak, Francis Hogle, Marshall McClintock, Mark Malamud, Suzan Marashi, and Mark Simpson for reviewing this design briefing and providing comments. Thanks to Lauren Gallagher, Shawna Sandeno, and Jennifer Shetterly for graphic design assistance.\n\nREFERENCES"}, {"url": "https://business.adobe.com/blog/basics/a-brief-history-of-ui-and-whats-coming", "page_content": "The History Of User Interfaces\u2014And Where They Are Heading\n\n\u201cA funny thing happens when you design a computer everyone can use.\u201d\n\nThat was the headline of a 1984 print campaign for Apple\u2019s newest device, the Macintosh. At the time the company was kicking off a revolution in personal computing with its graphical user interface (GUI) and mouse\u2014two innovations that helped democratize computing by making computers understandable and approachable for the average consumer.\n\nDuring the \u201990s and early 2000s, however, continued innovation stalled. But as the 2010s approached, a UI renaissance began that has led to many powerfully disruptive\u2014and, frankly, more human\u2014forms of interaction.\n\nSo where are we headed as the planet continues to digitize? To figure that out, we must start with a look at how we have interacted with computing to date and how those innovations have created the foundation for the newest forms of interaction.\n\n1960s-1980s\n\nAn IBM PC print ad from the 1980s showcased a\u2014wait for it!\u2014keyboard.\n\nFor much of the late 20th century, the keyboard dominated human interaction with computing technology. Mice yet, touch interfaces, voice control, and the like didn\u2019t exist. Still, the keyboard was a vast improvement over the punchcard, which had been used to program early computers in the 1940s and 1950s. But something happened in the early 1980s to dramatically change the environment \u2026\n\n1984\n\nSteve Jobs famously visited Xerox Parc in 1979, and the inspiration he found there in the form of a GUI and mouse is now the stuff of legend. In fact, these two UI innovations created a seismic event in technology adoption. Apple sold 1 million Macintoshes by 1988. IBM, Compaq, and others quickly followed with their own computer mice.\n\nMicrosoft, of course, followed this wave with the introduction of Windows 1.0 (in 1985), but it wasn\u2019t until Windows 3.1, in 1992, that it began to feel the GUI tailwind.\n\nApple introduced the Macintosh with a simple GUI and mouse, fundamentally changing the computing landscape.\n\n1994-1997\n\nAs the 1990s began, the laptop computer started to overtake the desktop. Along with that came incremental changes in the mouse/keyboard interface. Apple started incorporating trackballs and trackpads into its Powerbook laptops, while IBM introduced pointing sticks (branded \u201cTrackPoint\u201d) into its laptops.\n\nWhile computing continued miniaturizing from the desktop to the portable PC, a new device was also becoming popular: the PalmPilot. Along with the handheld form factor, Palm introduced a a new user interface, the stylus, which worked with its touchscreen, and an alternative alphabet it called \u201cGraffiti.\u201d\n\nThe PalmPilot introduced users to handwriting recognition through a stylus.\n\nVoice also started to become a form of interaction with the 1997 introduction of Dragon NaturallySpeaking. Dragon (and later Nuance, which acquired Dragon in 2000) sold several million copies of its voice interaction software, though it wouldn\u2019t be until the introduction of today\u2019s generation of voice assistants that voice would truly begin to take off as a form of computing interaction.\n\nDragon Systems introduced voice recognition and dictation to millions of users.\n\nEarly 2000s\n\nUI development was mostly incremental during the early 2000s, improving on already-established devices and tools:\n\nApple introduced the first commerically popular optical (non-trackball) mouse called the Pro Mouse. This was followed later on by the Mighty Mouse, which added touch and pressure sensitivity as an upgrade to the previous button-based interface. A multitouch Magic Mouse followed next, which allowed users to interact in more advanced ways using combinations of multiple fingers.\n\nApple also introduced the scroll wheel, another touch-based UI, with the rollout of iPod music devices in 2001. Over time, the scroll wheel became even more touch-sensitive, enabling Apple to remove all external buttons.\n\nThe many iterations of the iPod music player demonstrate how Apple continued to push the boundaries of UI design during the early 2000s.\n\n2007-2010\n\nThe latter part of the 2000s witnessed a big leap forward in UI design, again led by Apple. Touch interfaces took off dramatically with the introduction of the iPhone in 2007 and the iPad in 2010. For both these devices, multipoint capacity touch enabled users to interact with digital content in new ways. While Apple didn\u2019t invent this UI (it came from Fingerworks, which it acquired in 2005 to provide this), the company certainly democratized it, with other smartphone and tablet manufacturers all adopting forms of touch over the following years.\n\nApple introduced the world to touch interfaces with the iPhone and iPad.\n\n2011-Present\n\nWhile touch has become a ubiqitous part of the way we interact with digital content today (not just smartphones and tablets, but kiosks, ATMs, appliances, etc.), a revitalization is developing in voice as a user interface form.\n\nVoice assistants started to gain steam in 2011 with Apple\u2019s Siri voice assistant. Since then we\u2019ve also had the introduction of Google Now (2012) and Amazon\u2019s Alexa devices (2014). These services and devices depend on data and content assets acquired by these platforms to fullfill user requests.\n\nThus, when you ask Siri for directions, it can quickly leverage Apple Maps to provide a routing. Or when you ask an Amazon Echo (powered by Alexa) to play a song or read an Audible book, Alexa draws on those Amazon assets to play back your content.\n\nAmazon\u2019s Alexa-powered devices support the latest generation of voice interface.\n\nImmersive experiences enabled by a new generation of virtual and augmented reality devices add another dimension to user interfaces. Consumers and enterprises are just dipping their toes in the water around new forms of interactivity in gaming, architecture, real estate, engineering, and social networking, just to name a few examples.\n\nToday this means wearing a rather large head-mounted device and using a mouse or gaming controller to interact with virtual objects. But as haptic devices\u2014which allow for the perception and manipulation of objects using touch\u2014reach new levels of performance and miniaturization, one can imagine being able to touch, walk, run, and interact with virtual worlds in the same natural way we interact with the real world.\n\nThe state-of-the-art for immersive UI generally looks like this today (above)\u2026\n\nHaptic suits like, this one from Hardlight VR, enable users to interact more naturally and receive feedback from a virtual environment directly on their bodies.\n\nBringing Humanity Back To Computing\n\nIf you step back from the history we\u2019ve just walked through, you will see that UI design is heading in a clear direction: toward organic forms of interactivity that are native to our biology.\n\nLooking back, we can see that keyboards, mice, and trackpads were really just hacks meant to close the gap between spoken language and touch with computing surfaces. And they worked well for the better part of 30-plus years.\n\nNow we are on the edge of a return to more natural interfaces that involve our fingers, voices, and bodies in space. This is all made possible by advances in network infrastructure, cloud-based computing storage and computational power, and aggregation of the data needed to teach machines to understand and interpret our human interactions.\n\nThese advances open up all sorts of interesting possibilities:\n\nAttending a family member\u2019s college graduation virtually, with the ability to interact with the people around you in real time.\n\nVisiting a pastime or place with the ability to interact with the environment\u2014for example, visiting the Court of Henry VIII and actually speaking to the king and his courtiers.\n\nHosting a meeting in a virtual environment with attendees from different countries. Each participant speaks in the person\u2019s first language, while the others hear real-time translation into their first language.\n\nWe\u2019ve identified just a few of the exciting possiblities that might be unlocked by continuing advances in UI technology. As we bring more humanity back to computing, we will also be able to engage more of the population who no longer need to master typing or the complexities of a desktop interface to interact with digital content."}, {"url": "https://learn.microsoft.com/en-us/windows/win32/appuistart/user-interface-technologies-for-windows-applications", "page_content": "Table of contents\n\nUser Interface Technologies\n\nArticle\n\n08/19/2020\n\n4 contributors Feedback\n\nIn this article\n\nThis topic provides a brief survey of the Microsoft technologies for developing UIs for Windows-based applications. It provides the information required to help you determine whether to use a particular technology, and identifies where you can find more information about it.\n\nThis topic describes the following technologies:\n\nUser Interface Technologies for Unmanaged Applications\n\nThis section describes the Microsoft technologies for developing UIs for unmanaged Windows applications. These technologies are intended for experienced C/C++ developers who are familiar with WindowsAPI programming concepts, and who are using the Microsoft Windows Software Development Kit (SDK). Some technologies have additional prerequisites such as knowledge of graphics programming issues or familiarity with the basics of Component Object Model (COM) programming.\n\nWindows Controls\n\nWindows controls are user interface elements that are used in conjunction with another window (typically a client window or dialog box) to enable the user to interact with an application. Many of the elements that make up the UI of a traditional Windows-based application are Windows controls, including items such as menus, scroll bars, buttons, list boxes, tree views, and so on.\n\nWindows controls are supported by all versions of Windows. However, because the run-time components that support the controls have evolved over time, some controls and features introduced in later versions are not supported in earlier versions. Applications need to detect the versions and use only the available features.\n\nYou should use Windows controls if you want to create a traditional UI for an unmanaged Windows-based application that runs on a wide range of Windows versions.\n\nFor more information, see Windows Controls.\n\nVisual Styles\n\nVisual Styles are specifications for the appearance of controls. For example, a Visual Style can define the overall appearance of controls, and enable software developers to configure the visual interface of those controls to coordinate with an application's appearance. Additionally, Visual Styles provide a mechanism for all Windows-based applications to standardize an application's appearance.\n\nVisual styles are supported on Windows XP and later, and they only affect the appearance of the standard Windows controls and the Microsoft Win32 common controls.\n\nYou should use Visual Styles if you need to change the appearance of the standard Windows controls and common controls to match the look of your application UI.\n\nFor more information, see Visual Styles.\n\nWindows Ribbon Framework\n\nThe Windows Ribbon framework is a rich command presentation system for Windows-based applications. It consists of a ribbon command bar that exposes the major features of an application through a series of tabs at the top of an application window, and a context menu system. The Windows Ribbon framework is supported on the following Windows versions:\n\nWindows Vista with Service Pack 2 (SP2) and Platform Update for Windows Vista\n\nWindows 7 and later\n\nWindows Server 2008 R2\n\nWindows Server 2008 with Service Pack 2 (SP2) and Platform Update for Windows Server 2008\n\nYou should use Windows Ribbon framework if you want to implement a command UI that is an alternative to the layered menus, toolbars, and task panes of traditional Windows applications.\n\nThe Windows Ribbon framework is intended for developers who are proficient in COM programming.\n\nFor more information, see Windows Ribbon Framework.\n\nWindows Animation Manager\n\nThe Windows Animation Manager supports the animation of UI elements by providing a powerful animation engine and a standardized programmatic interface. The platform simplifies the development and maintenance of UI animation sequences and enables developers to implement UI animations that are consistent and intuitive. Windows Animation can be used with any graphics platform including Direct2D, Microsoft Direct3D, or Windows GDI+.\n\nThe Windows animation framework is supported on Windows Vista with Platform Update for Windows VistaWindows Vista with SP2 and Platform Update for Windows Vista, and Windows 7 and later.\n\nYou should use Windows Animation Manager if you want to add animation sequences to the UI of an unmanaged Windows-based application.\n\nFor more information, see Windows Animation Manager.\n\nDesktop Window Manager\n\nDesktop Window Manager (DWM) is a Windows run-time component that supports desktop composition, a feature introduced in Windows Vista. Through desktop composition, DWM enables visual effects in the UI, such as glass window frames, 3-D window transition animations, Windows Flip and Windows Flip3D, and high resolution support.\n\nDWM exposes an API for controlling many of the visual effects associated with desktop composition. For example, an application can display thumbnails, apply a translucent and blurred effect to the client area of top-level windows, control the transparency and transition effects used in the non-client region of windows, and so on.\n\nDWM is supported on Windows Vista and Windows Server 2008.\n\nYou should use DWM if your application needs to access and control the visual effects associated with desktop composition.\n\nFor more information, see Desktop Window Manager.\n\nWindows Automation API\n\nThe Windows Automation API helps developers create applications that are accessible to the widest possible audience, including people with vision, hearing, or motion disabilities. The API works by exposing information about the elements that make up an application user interface. Assistive technology applications such as screen readers can use the information to present the UI in a way that can be used by people with disabilities.\n\nThe Windows Automation API consists of two separate API frameworks, Microsoft Active Accessibility and Microsoft UI Automation. Microsoft Active Accessibility is a legacy API that was introduced in Windows 95 as a platform add-in. UI Automation is the successor to Microsoft Active Accessibility, and is a Windows implementation of the UI Automation specification.\n\nFull support for Microsoft Active Accessibility is built into Windows XP and Windows Server 2003. Microsoft Active Accessibility is also supported on Windows NT 4.0 with Service Pack 6 (SP6) and later, and Windows 98. UI Automation is supported on the following operating systems: Windows XP, Windows Server 2003, Windows Server 2003 R2, Windows Vista, Windows 7, Windows Server 2008, and Windows Server 2008 R2.\n\nIf your application contains custom controls or other custom UI features, you should use the Windows Automation API to ensure that the custom controls and features are fully accessible. In general, developers need a moderate level of understanding about COM objects and interfaces, Unicode, and Windows API programming.\n\nFor more information, see Windows Automation API.\n\nSpeech API\n\nThe Microsoft Speech API (SAPI) provides a high-level interface between an application and speech engines. SAPI implements all the low-level details needed to control and manage the real-time operations of various speech engines.\n\nThe two basic types of SAPI engines are text-to-speech (TTS) systems and speech recognizers. TTS systems synthesize text strings and files into spoken audio using synthetic voices. Speech recognizers convert human spoken audio into readable text strings and files.\n\nYou should use SAPI if you want to implement a UI that enables the user to interact with your application through TTS and speech recognition in addition to the standard input devices such as the keyboard, mouse, and display.\n\nFor more information, see Microsoft Speech API (SAPI) 5.4.\n\nMagnification API\n\nThe magnification API (MAPI) is used to magnify portions of the screen, and to apply color effects and other transforms. This API is primarily intended for assistive-technology applications that enlarge parts of the screen to make them easier to see.\n\nMAPI is supported on Windows Vista, Windows 7, Windows Server 2008, and Windows Server 2008 R2. It is intended for developers who are familiar with graphics programming concepts.\n\nFor more information, see Magnification API.\n\nResource Compiler\n\nThe Microsoft Windows Resource Compiler is an application development tool used to add UI and other resources to a Windows-based application. A resource is any non-executable data used by an application, and includes such things as dialog boxes, menus, strings, cursors, icons, bitmaps, and so on. The resource compiler is included in Microsoft Visual Studio and the Windows SDK.\n\nFor more information, see Resource Compiler.\n\nUser Interface Technologies for Managed Applications\n\nThis section describes the Microsoft technologies for developing UIs for managed Windows applications that run in the context of the .NET Framework. For more information, see .NET Development.\n\nWindows Forms\n\nWindows Forms is a graphical application programming interface for creating managed Windows applications that are based on the .NET Framework. In Windows Forms, a form is a visual surface on which you display information to the user, and through which you receive input from the user.\n\nYou build Windows Forms applications by adding controls to forms and developing responses to user actions, such as mouse clicks or key presses. A control is a discrete UI element that displays data or accepts data input. Windows Forms contains a variety of controls that you can add to forms: controls that display text boxes, buttons, drop-down boxes, radio buttons, and even Web pages. Windows Forms also supports creating custom controls.\n\nFor more information, see Windows Forms.\n\nWindows Presentation Foundation\n\nWindows Presentation Foundation (WPF) is the successor to Windows Forms. WPF is a presentation system for building and rendering user interfaces in Windows-based client applications and browser-hosted applications. The core of WPF is a resolution-independent and vector-based rendering engine that is built to take advantage of modern graphics hardware. WPF extends the core with a comprehensive set of application-development features that include Extensible Application Markup Language (XAML), controls, data binding, layout, 2-D and 3-D graphics, animation, styles, templates, documents, media, text, and typography.\n\nWPF is included in the .NET Framework, so you can build applications that incorporate other elements of the .NET Framework class library. WPF is supported on Windows Vista, Windows 7, Windows Server 2008, Windows Server 2008 R2, and is also available for Windows XP with Service Pack 2 (SP2), and Windows Server 2003.\n\nFor more information, see Windows Presentation Foundation.\n\nSilverlight\n\nMicrosoft Silverlight is a powerful development platform for creating rich media applications and business applications for the Web, desktop, and mobile devices.\n\nBased on the .NET Framework, the free Silverlight plug-in works across multiple browsers, devices, and operating systems to bring new interactivity to the Web. With extensive layout and styling options, powerful communication protocols, robust data access, and support for user interaction and high-definition media, Silverlight helps create fast, smooth, and visually rich customer experiences. Silverlight applications can be developed quickly with the Microsoft Web Platform, Visual Studio, and Expression Studio.\n\nFor more information, see Microsoft Silverlight.\n\nExpression Blend 3 + SketchFlow\n\nExpression Blend 3 + SketchFlow is a visual tool for designing, prototyping, and creating sophisticated user interfaces for WPF and Silverlight desktop and web applications. You build an application by drawing shapes, drawing controls such as buttons and list boxes, making the pieces of your application respond to mouse clicks and other user input, and styling everything to look uniquely your own.\n\nFor more information, see Prototyping with SketchFlow.\n\nUI Automation for Managed Applications\n\nUI Automation is an accessibility framework for Windows, available on all operating systems that support WPF.\n\nUI Automation provides programmatic access to most UI elements on the desktop, enabling assistive technology products such as screen readers to provide information about the UI to end users and to manipulate the UI by means other than standard input. UI Automation also allows automated test scripts to interact with the UI.\n\nFor more information, see UI Automation for Managed Applications."}, {"url": "https://learn.microsoft.com/en-us/windows/win32/appuistart/getting-started-developing-user-interfaces-portal", "page_content": "Table of contents\n\nGetting Started Developing User Interfaces for Windows Applications\n\nArticle\n\n04/27/2021\n\n4 contributors Feedback\n\nIn this article\n\nPurpose\n\nThe following sections offer general guidance to developers who are designing, implementing, and testing the user interface of a Windows application.\n\nIn addition to basic user interface design principles, numerous recommendations and suggestions are provided that will help developers provide a user experience that is as simple, efficient, and enjoyable as possible.\n\nNote These guidelines are not intended to be comprehensive and are subject to the specific scope and functionality of an application. For more comprehensive guidelines, see the Windows User Experience Interaction Guidelines.\n\nIn this section"}, {"url": "http://tedchilds.com/", "page_content": "-- Keith H. Hammonds\n\nFast Company Magazine\n\n\u2026 Since 1995, though, IBM has acquired a different look, largely because of Childs\u2019 strategic campaign to overhaul the company\u2019s practices pertaining to hiring and promoting women, ethnic minorities, and other groups that are underrepresented at IBM."}, {"url": "https://sites.psu.edu/jmc7765/2019/10/24/ted-talk-the-windows-and-mirrors-of-your-childs-bookshelf/", "page_content": "Recently, the importance of diversity in entertainment has been broadcast across the country. Movies like Blank Panther and Crazy Rich Asians garnered acclaim for showing non-white stories to be complex and marketable in a historically racist industry.\n\nLike the entertainment field, the book industry has been dominated by white stories. The majority of novels read in school were written by white people about white people. In \u201cThe Windows and Mirrors of Your Child\u2019s Bookshelf,\u201d Grace Lin says that people of color lack novels that reflect themselves, or mirrors. Mirrors teach children that they are important. And without these mirrors, people of color are left feeling unvalued. Lost. But books, Lin argues, aren\u2019t only mirrors. They are also windows. Books, like windows, provide views into new, unknown worlds. They teach us not only how to respect but how to appreciate the incredible diversity that exists between us.\n\nI will admit that Lin sounds a bit patronizing at the beginning of her Ted Talk, and I chalk that down to her job as a children\u2019s book writer. But she quickly rebounded, finding herself on stage, and delivered an eloquent, meaningful talk, one that not only calls out a problem but provides an easy, immediate solution.\n\nThroughout the talk, Lin tells the story about grappling with her Taiwanese identity, unable to recognize herself in the books she read nor the mirrors she looked in. And when she mentioned auditioning for Dorothy to her friend for the school play, she was told she couldn\u2019t, because she was Asian. But eventually, when she wrote her own book, Where the Mountain Meets the Moon, children across the country wanted to be the Asian protagonist. Though what sticks with me most from the Ted Talk is words she chooses to use, specifically those used to end her talk: \u201cWhen you go home, please, look at your child\u2019s bookshelf. Are all the books mirrors, or are all of them windows? Make sure that you have both, because if you do, you\u2019re setting the path for self-worth and empathy, and that is a brick road worth following.\u201d\n\nFrom the Ted Talk, my main takeaways are the following:"}]}